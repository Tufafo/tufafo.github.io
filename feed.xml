<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2024-05-23T21:16:35+08:00</updated><id>/feed.xml</id><title type="html">甲与</title><author><name>甲与</name></author><entry><title type="html">测试</title><link href="/%E6%B5%8B%E8%AF%95/" rel="alternate" type="text/html" title="测试" /><published>2024-04-29T00:00:00+08:00</published><updated>2024-04-29T00:00:00+08:00</updated><id>/%E6%B5%8B%E8%AF%95</id><content type="html" xml:base="/%E6%B5%8B%E8%AF%95/"><![CDATA[<p>This is a test of elisp.</p>

<h2 id="test">test</h2>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">;;=&gt;5</span>
</code></pre></div></div>

<h2 id="这是一份测试文档">这是一份测试文档</h2>

<h2 id="测试">测试</h2>

<p>12312321312</p>]]></content><author><name>甲与</name></author><category term="测试" /><summary type="html"><![CDATA[This is a test of elisp.]]></summary></entry><entry><title type="html">Minio实训</title><link href="/minio%E5%AE%9E%E8%AE%AD/" rel="alternate" type="text/html" title="Minio实训" /><published>2024-04-27T00:00:00+08:00</published><updated>2024-04-27T00:00:00+08:00</updated><id>/minio%E5%AE%9E%E8%AE%AD</id><content type="html" xml:base="/minio%E5%AE%9E%E8%AE%AD/"><![CDATA[<h2 id="目标">目标</h2>

<ul>
  <li>熟悉minio的配置过程和客户端操作</li>
  <li>通过面向elisp的命令封装来模拟hbase以实现实训要求。</li>
</ul>

<h2 id="环境简介">环境简介</h2>

<p>由于之前配置hbase集群中，集群在sshd命令上消耗流量过高，vps流量超额欠费。现使用部署成本更加低廉的minio完成分布式实训任务。</p>

<p><img src="/assets/post_images/image-20240420095141618.png" alt="" />
<img src="/assets/post_images/image-20240420095613423.png" alt="" /></p>

<p>MinIO 是一种高性能，兼容S3对象存储。特别是它的客户端mc内置了sql查询操作，使得可以直接在csv文件中进行查询。</p>

<p>环境：centos7。</p>

<h2 id="服务器配置过程">服务器配置过程</h2>

<h3 id="单节点单磁盘">单节点单磁盘</h3>

<ul>
  <li>下载并安装minio</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://dl.min.io/server/minio/release/linux-amd64/archive/minio-20240418190919.0.0-1.x86_64.rpm <span class="nt">-O</span> minio.rpm
<span class="nb">sudo </span>yum <span class="nb">install </span>minio.rpm
</code></pre></div></div>

<ul>
  <li>创建数据文件夹</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> ~/minio
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minio server ~/minio <span class="nt">--console-address</span> :9001
</code></pre></div></div>

<p>一些常用的参数：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">--address &lt;address:port&gt;/&lt;:port&gt;</code> 指定api端口</li>
  <li><code class="language-plaintext highlighter-rouge">--console-address &lt;address:port&gt;/&lt;:port&gt;</code> 指定webUI端口</li>
</ul>

<p>访问 <code class="language-plaintext highlighter-rouge">&lt;server-ip:9001&gt;</code> ，查看<code class="language-plaintext highlighter-rouge">minio</code>登录页面。
<img src="/assets/post_images/image-20240427144736126.png" alt="" /></p>

<p>输入账号密码，默认：<code class="language-plaintext highlighter-rouge">minioadmin</code>。</p>

<p>在 <code class="language-plaintext highlighter-rouge">Administrator-Monitoring-Metrics</code> 目录下可以看到当前各节点的工作状态。</p>

<p><img src="/assets/post_images/image-20240427144850027.png" alt="" /></p>

<h3 id="单节点多磁盘">单节点多磁盘</h3>

<p>安装过程同上，但是启动不同。在linux中一般通过<code class="language-plaintext highlighter-rouge">mount</code>命令将磁盘挂载到某目录下。现在新建四个文件夹来代表不同节点。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> ~/minios
<span class="nb">mkdir</span> ~/minios/m1
<span class="nb">mkdir</span> ~/minios/m2
<span class="nb">mkdir</span> ~/minios/m3
<span class="nb">mkdir</span> ~/minios/m4
</code></pre></div></div>

<p>启动时，只需要将多个节点的序号放在大括号中即可。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minio server ~/minios/m<span class="o">{</span>1...4<span class="o">}</span> <span class="nt">--console-address</span> :9001
</code></pre></div></div>

<p>访问服务器 <code class="language-plaintext highlighter-rouge">9001</code> 端口，可以看到，磁盘数从一增长为4：</p>

<p><img src="/assets/post_images/image-20240427145838228.png" alt="" /></p>

<h2 id="多节点多磁盘失败">多节点多磁盘（失败）</h2>

<p><code class="language-plaintext highlighter-rouge">minio</code> 安装同上。</p>

<p>在各个节点增加新的 <code class="language-plaintext highlighter-rouge">hosts</code> 映射到 <code class="language-plaintext highlighter-rouge">/etc/hosts</code> 文件中：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip1 n1
ip2 n2
</code></pre></div></div>

<p>创建文件夹代表不同磁盘：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /data
mkdir /data/data1
mkdir /data/data2
mkdir /data/data3
mkdir /data/data4
</code></pre></div></div>

<p>设置环境变量：</p>

<ul>
  <li>在<code class="language-plaintext highlighter-rouge">~/.bashrc</code>中</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">MINIO_ACCESS_KEY</span><span class="o">=</span>minioadmin <span class="c"># 设置用户名</span>
<span class="nb">export </span><span class="nv">MINIO_SECRET_KEY</span><span class="o">=</span>minioadmin <span class="c">#设置密码</span>
<span class="nb">export </span><span class="nv">CI</span><span class="o">=</span><span class="nb">true</span> <span class="c"># 允许访问root磁盘</span>
<span class="nb">export </span><span class="nv">MINIO_CI_CD</span><span class="o">=</span><span class="nb">true</span> <span class="c"># 允许访问root磁盘</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source</span> ~/.bashrc
</code></pre></div></div>

<p>在各个服务器的命令行中启动 <code class="language-plaintext highlighter-rouge">minio</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minio server http://n<span class="o">{</span>1...2<span class="o">}</span>:9000/data/data<span class="o">{</span>1...4<span class="o">}</span> 
</code></pre></div></div>

<p>两次配置结果，第一次成功访问。后服务器过期，更换现vps厂商执行同样的命令出现错误：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WARNING: MINIO_ACCESS_KEY and MINIO_SECRET_KEY are deprecated.
         Please use MINIO_ROOT_USER and MINIO_ROOT_PASSWORD

API: SYSTEM.peers
Time: 07:08:56 UTC 04/27/2024
Error: Expected number of all hosts <span class="o">(</span>2<span class="o">)</span> to be remote +1 <span class="o">(</span>2<span class="o">)</span> <span class="o">(</span><span class="k">*</span>errors.errorString<span class="o">)</span>
       8: internal/logger/logger.go:259:logger.LogIf<span class="o">()</span>
       7: cmd/logging.go:42:cmd.peersLogIf<span class="o">()</span>
       6: cmd/peer-rest-client.go:631:cmd.newPeerRestClients<span class="o">()</span>
       5: cmd/notification.go:1152:cmd.NewNotificationSys<span class="o">()</span>
       4: cmd/server-main.go:400:cmd.initAllSubsystems<span class="o">()</span>
       3: cmd/server-main.go:715:cmd.serverMain.func4<span class="o">()</span>
       2: cmd/server-main.go:512:cmd.bootstrapTrace<span class="o">()</span>
       1: cmd/server-main.go:714:cmd.serverMain<span class="o">()</span>
ERROR Unable to configure server grid RPC services: grid: <span class="nb">local </span>host not found
</code></pre></div></div>

<p>解释：</p>

<p>错误直接原因，无法配置服务网格的远程过程调用（RPC）服务，无法找到本地主机。</p>

<p>很多VPS厂商会限制节点在内网中的通信，特别是这种廉价服务器，甚至没有独立的公网ip，只有五个端口到内网的映射。</p>

<p><img src="/assets/post_images/image-20240427151348771.png" alt="" /></p>

<p>端口映射的概念如下图所示：</p>

<p><img src="/assets/post_images/image-20240427151517425.png" alt="" /></p>

<p>这是新vps电商和旧vps电商在端口上的最大不同。但是在单个节点通过 <code class="language-plaintext highlighter-rouge">ssh</code> 和公网ip可以访问本节点或另一节点，均无问题。那么，如果<strong>更换为内网ip</strong>进行访问如何呢？</p>

<p><img src="/assets/post_images/image-20240427152533333.png" alt="" /></p>

<p><img src="/assets/post_images/image-20240427152630076.png" alt="" /></p>

<p>更新两个节点中 <code class="language-plaintext highlighter-rouge">host</code> 文件中的映射关系。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10.41.14.22 N1
10.47.14.21 N2
</code></pre></div></div>

<p>但是重新启动依然出现错误：</p>

<p><img src="/assets/post_images/image-20240427152845650.png" alt="" /></p>

<p>至此，由于单节点多磁盘和单节点单磁盘的差别不大，此后由单节点多磁盘环境继续进行实验。</p>

<p>不过要主要把进程挂载到后台。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">nohup </span>minio server ~/minios/m<span class="o">{</span>1...4<span class="o">}</span> <span class="nt">--console-address</span> :14216 <span class="nt">--address</span> :14215 &amp;
</code></pre></div></div>

<h2 id="客户端配置过程">客户端配置过程</h2>

<h3 id="命令行端-mc">命令行端 MC</h3>

<p>安装</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://dl.min.io/client/mc/release/linux-amd64/mc
<span class="nb">chmod</span> +x mc
<span class="nb">sudo mv </span>mc /usr/local/bin/mc
</code></pre></div></div>

<p>设置用户</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc <span class="nb">alias set </span>m1 http://ip:9000 minioadmin minioadmin
</code></pre></div></div>

<p>操作：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc <span class="nt">--help</span> 查看命令帮助
</code></pre></div></div>

<p>基本的路径格式是 <code class="language-plaintext highlighter-rouge">alias 设置的登录名+桶名+对象路径</code> 。</p>

<p>创建桶</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc mb m1/&lt;bucket-name&gt;
</code></pre></div></div>

<p><img src="/assets/post_images/image-20240427153758844.png" alt="" /></p>

<p>上传文件</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"I am a good student."</span> <span class="o">&gt;</span> test.txt
mc put test.txt m1/stu
</code></pre></div></div>

<p>查看<code class="language-plaintext highlighter-rouge">stu</code> 目录下的文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc <span class="nb">ls </span>m1/stu
</code></pre></div></div>

<p><img src="/assets/post_images/image-20240427153959611.png" alt="" /></p>

<p>下载文件</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc get m1/stu ./
</code></pre></div></div>

<p>其它</p>

<table>
  <thead>
    <tr>
      <th>命令</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">alias</code></td>
      <td>在配置文件中管理服务器凭据</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">admin</code></td>
      <td>管理MinIO服务器</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anonymous</code></td>
      <td>管理对存储桶和对象的匿名访问</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">batch</code></td>
      <td>管理批处理作业</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cp</code></td>
      <td>复制对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cat</code></td>
      <td>显示对象内容</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">diff</code></td>
      <td>列出两个存储桶之间对象名称、大小和日期的差异</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">du</code></td>
      <td>递归总结磁盘使用情况</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">encrypt</code></td>
      <td>管理存储桶加密配置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">event</code></td>
      <td>管理对象通知</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">find</code></td>
      <td>搜索对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">get</code></td>
      <td>将S3对象获取到本地</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">head</code></td>
      <td>显示对象的前n行</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ilm</code></td>
      <td>管理存储桶生命周期</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">idp</code></td>
      <td>管理MinIO身份提供者服务器配置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">license</code></td>
      <td>许可证相关命令</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">legalhold</code></td>
      <td>管理对象的法律保留</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ls</code></td>
      <td>列出存储桶和对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">mb</code></td>
      <td>创建一个存储桶</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">mv</code></td>
      <td>移动对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">mirror</code></td>
      <td>将对象同步到远程站点</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">od</code></td>
      <td>测量单个流上传和下载</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ping</code></td>
      <td>执行存活性检查</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pipe</code></td>
      <td>将标准输入流传输到对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">put</code></td>
      <td>将对象上传到存储桶</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">quota</code></td>
      <td>管理存储桶配额</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rm</code></td>
      <td>删除对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">retention</code></td>
      <td>为对象设置保留期</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rb</code></td>
      <td>删除一个存储桶</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">replicate</code></td>
      <td>配置服务器端存储桶复制</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ready</code></td>
      <td>检查集群是否就绪</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sql</code></td>
      <td>在对象上运行SQL查询</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">stat</code></td>
      <td>显示对象元数据</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">support</code></td>
      <td>支持相关命令</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">share</code></td>
      <td>生成临时访问对象的URL</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">tree</code></td>
      <td>以树状格式列出存储桶和对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">tag</code></td>
      <td>管理存储桶和对象的标签</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">undo</code></td>
      <td>撤销PUT/DELETE操作</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">update</code></td>
      <td>将mc更新到最新版本</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">version</code></td>
      <td>管理存储桶版本控制</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">watch</code></td>
      <td>监听对象通知事件</td>
    </tr>
  </tbody>
</table>

<h3 id="执行sql查询">执行sql查询</h3>

<p>在 <code class="language-plaintext highlighter-rouge">Libre Office</code> 中创建表格，保存为 <code class="language-plaintext highlighter-rouge">.csv</code> 文件，上传到 ` minio-server` 中</p>

<p><img src="/assets/post_images/image-20240427154434731.png" alt="" /></p>

<p><img src="/assets/post_images/image-20240427154557914.png" alt="" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc put s1.csv m1/stu
</code></pre></div></div>

<p>查询文件</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc sql <span class="nt">--recursive</span> <span class="nt">--query</span> <span class="s2">"select * from S3Object"</span> m1/stu/s1.csv
</code></pre></div></div>

<p><img src="/assets/post_images/image-20240427155030473.png" alt="" /></p>

<p>增加查询条件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc sql <span class="nt">--recursive</span> <span class="nt">--query</span> <span class="s2">"select * from S3Object where </span><span class="se">\"</span><span class="s2">成绩</span><span class="se">\"</span><span class="s2"> &gt; 7"</span> m1/stu/s1.csv
</code></pre></div></div>

<p><img src="/assets/post_images/image-20240427155132623.png" alt="" /></p>

<h2 id="在elisp中进行封装">在elisp中进行封装</h2>

<p>函数：</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="nb">defun</span> <span class="nv">as-s3o-be-sq</span> <span class="p">(</span><span class="nv">s3o</span> <span class="nv">sq</span><span class="p">)</span>
    <span class="s">"make a sq query to s3o on minio server.
    The input of s3o should be a string path to s3o, and sq
    should be a string of sql. This function will return query result as string"</span>
    <span class="p">(</span><span class="nv">shell-command-to-string</span> <span class="p">(</span><span class="nb">format</span> <span class="s">"mc sql --recursive --query \"%s\" %s"</span> <span class="nv">sq</span> <span class="nv">s3o</span><span class="p">)))</span>
</code></pre></div></div>

<p>测试：</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">as-s3o-be-sq</span> <span class="s">"m1/stu/s1.csv"</span> <span class="s">"select * from S3Object"</span><span class="p">)</span>
<span class="c1">;=&gt;</span>
<span class="c1">;张三,10</span>
<span class="c1">;李四,8.9</span>
<span class="c1">;王五,6.7</span>
</code></pre></div></div>

<p>至此，完成实训所需的基本构件已经完成。</p>

<h3 id="实训任务">实训任务</h3>

<h3 id="任务一设计表">任务一，设计表</h3>

<p>统计长度：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">wc</span> <span class="nt">-l</span> stumer_in_out_details.txt 
<span class="c">#975541 stumer_in_out_details.txt</span>
</code></pre></div></div>

<p>可以看到，一共975541行数据。由于minio会自动执行文件的分割编码和存储过程，并且考虑到文件格式和<code class="language-plaintext highlighter-rouge">csv</code>文件格式一致，直接改名为<code class="language-plaintext highlighter-rouge">csv</code> 文件，在首部增加属性行上传文件即可。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sed -i "1i\钞票冠字号,时间,用户ID,存取钞票银行" stumer_in_out_details.txt
</code></pre></div></div>

<p>插入效果如下：</p>

<p><img src="/assets/post_images/image-20240427165407255.png" alt="" /></p>

<p>上传文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mv </span>stumer_in_out_details.txt stumer_in_out_details.csv
mc put ./stumer_in_out_details.csv m1/stu/
mc <span class="nb">head</span> <span class="nt">-n</span> 3 m1/stu/stumer_in_out_details.csv
</code></pre></div></div>

<p>封装命令到elisp中。</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">as-o-be-put</span> <span class="p">(</span><span class="nv">file</span> <span class="nv">path</span><span class="p">)</span>
	<span class="s">"The first file be put to the path of Minio."</span>
	<span class="p">(</span><span class="nv">shell-command</span> <span class="p">(</span><span class="nb">format</span> <span class="s">"mc put %s %s"</span> <span class="nv">file</span> <span class="nv">path</span><span class="p">)))</span>
</code></pre></div></div>

<h3 id="任务二表格的创建和删除">任务二：表格的创建和删除</h3>

<p>考虑到在 Minio中数据表可以直接以csv形式存储，但却没有提供数据修改功能。所以一切的增删改功能都需要下载文件到本地修改。并且可以把一个”bucket“视为一个数据库，一个”object“视为一个表。而本地修改部分可以依赖<code class="language-plaintext highlighter-rouge">linux</code> 三剑客之一<code class="language-plaintext highlighter-rouge">sed</code>命令。</p>

<p>创建命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"&lt;attribute-name-1&gt;,&lt;attribute-name-2&gt;,..."</span> <span class="o">&gt;</span> &lt;table-name&gt;.csv
mc put &lt;table-name&gt;.csv m1/&lt;db-name&gt;
<span class="nb">rm</span> &lt;table-name&gt;.csv
</code></pre></div></div>

<p>删除命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc <span class="nb">rm</span> &lt;table-path&gt;
mc rb &lt;db-path&gt;
</code></pre></div></div>

<p>修改命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc get &lt;table-path&gt; &lt;local-path&gt;
<span class="nb">echo</span> <span class="s2">"&lt;new-datas&gt;"</span> <span class="o">&gt;&gt;</span> &lt;local-path&gt;/&lt;table-path&gt; <span class="c">#增加行</span>
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'/pattern/d'</span> &lt;local-path&gt;/&lt;table-name&gt; <span class="c">#按照模式删除行</span>
mc put &lt;local-path&gt;/&lt;table-name&gt; &lt;table-path&gt;
</code></pre></div></div>

<h3 id="任务三查询指定时间版本的数据">任务三：查询指定时间版本的数据</h3>

<p>以csv文件保存的数据是一个不可分割的整体，没有办法单独为一行数据建立多个时间版本。最好的做法是在不同时间备份多个csv文件，通过<code class="language-plaintext highlighter-rouge">mc ls</code> 命令查看数据保存时间。并从中筛选需要的时间段。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc <span class="nb">cp</span> &lt;table-path&gt; &lt;table-path&gt;-&lt;data&gt; <span class="c">#备份数据</span>
mc sql <span class="nt">--recursive</span> <span class="nt">--query</span> <span class="s2">"&lt;sql&gt;"</span> &lt;table-path&gt;-&lt;data&gt;
</code></pre></div></div>

<h3 id="任务四利用elisp函数封装创建表">任务四：利用elisp函数封装创建表</h3>

<p>函数：</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">as-table-be-create-in</span> <span class="p">(</span><span class="nv">table-name</span> <span class="nv">attributes</span> <span class="nv">db-path</span><span class="p">)</span>
	<span class="s">"Create the table in Minio"</span>
	<span class="p">(</span><span class="nv">shell-command</span> <span class="p">(</span><span class="nb">format</span> <span class="s">"echo \"%s\" &gt; %s.csv 
							 mc put %s.csv %s
							 rm %s.csv"</span> 
					<span class="nv">attributes</span> <span class="nv">table-name</span> <span class="nv">table-name</span> <span class="nv">db-path</span> <span class="nv">table-name</span><span class="p">)))</span>
</code></pre></div></div>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">as-s3o-be-list</span> <span class="p">(</span><span class="nv">s3o-path</span><span class="p">)</span>
	<span class="s">"ls the s3o in minio"</span>
	<span class="p">(</span><span class="nv">shell-command-to-string</span> <span class="p">(</span><span class="nb">format</span> <span class="s">"mc ls %s"</span> <span class="nv">s3o-path</span><span class="p">)))</span>
</code></pre></div></div>

<p>测试：</p>

<p><img src="/assets/post_images/image-20240427203158705.png" alt="" /></p>

<h3 id="任务五通过elisp插入数据到表并查询">任务五：通过elisp插入数据到表并查询</h3>

<p>函数：</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="nb">defun</span> <span class="nv">as-data-be-insert</span> <span class="p">(</span><span class="nv">data</span> <span class="nv">table-path</span><span class="p">)</span>
    <span class="s">"insert data to minio table"</span>
    <span class="p">(</span><span class="nv">shell-command</span> <span class="p">(</span><span class="nb">format</span>
		    <span class="s">"mc get %s ./tmp.csv
                     mc rm %s
		     echo \"%s\" &gt;&gt; ./tmp.csv
		     mc put ./tmp.csv %s
		     rm ./tmp.csv"</span>
		    <span class="nv">table-path</span> <span class="nv">table-path</span> <span class="nv">data</span> <span class="nv">table-path</span>
		    <span class="p">)))</span>
</code></pre></div></div>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">(</span><span class="nb">defun</span> <span class="nv">as-s3o-be-get-heads</span> <span class="p">(</span><span class="nv">s3o-path</span> <span class="nv">num</span><span class="p">)</span>
      <span class="s">"get the head lines of s3o"</span>
      <span class="p">(</span><span class="nv">shell-command-to-string</span> <span class="p">(</span><span class="nb">format</span> <span class="s">"mc head -n %d %s"</span> <span class="nv">num</span> <span class="nv">s3o-path</span><span class="p">)))</span>
</code></pre></div></div>

<p>测试：</p>

<p><img src="/assets/post_images/image-20240427205605541.png" alt="" /></p>

<h3 id="任务六利用elisp合并数据">任务六：利用elisp合并数据</h3>

<p>按照原本的实训要求，此处应该为导入数据。但是考虑到minio中并不需要转换数据格式，所以与其刻意把数据导入elisp中，不如考虑如何合并两个表。假设表A和表B具有相同的结构，现在用elisp把它们合并到一起。</p>

<p>函数：</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="nb">defun</span> <span class="nv">as-file-be-read</span> <span class="p">(</span><span class="nv">file</span><span class="p">)</span>
    <span class="s">"fill be read to string"</span>
    <span class="p">(</span><span class="nv">with-temp-buffer</span>
      <span class="p">(</span><span class="nv">insert-file-contents</span> <span class="nv">file</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">buffer-string</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">defun</span> <span class="nv">as-str-be-append</span> <span class="p">(</span><span class="nv">str</span> <span class="nv">file</span><span class="p">)</span>
    <span class="s">"str be append to file"</span>
    <span class="p">(</span><span class="nv">with-temp-buffer</span>
      <span class="p">(</span><span class="nv">insert</span> <span class="nv">str</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">append-to-file</span> <span class="p">(</span><span class="nv">point-min</span><span class="p">)</span> <span class="p">(</span><span class="nv">point-max</span><span class="p">)</span> <span class="nv">file</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">defun</span> <span class="nv">as-file-be-append</span> <span class="p">(</span><span class="nv">file-a</span> <span class="nv">file-b</span><span class="p">)</span>
    <span class="s">"merge two files"</span>
    <span class="p">(</span><span class="nv">as-str-be-append</span> <span class="p">(</span><span class="nv">as-file-be-read</span> <span class="nv">file-a</span><span class="p">)</span> <span class="nv">file-b</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">defun</span> <span class="nv">as-tables-be-merged</span> <span class="p">(</span><span class="nv">table-a</span> <span class="nv">table-b</span> <span class="nv">new-table</span><span class="p">)</span>
    <span class="s">"Both table be merged into one."</span>
    <span class="p">(</span><span class="nv">shell-command</span> <span class="p">(</span><span class="nv">concat</span>
		    <span class="p">(</span><span class="nb">format</span> <span class="s">"mc get %s ./tba \n"</span> <span class="nv">table-a</span><span class="p">)</span>
		    <span class="p">(</span><span class="nb">format</span> <span class="s">"mc get %s ./tbb \n"</span> <span class="nv">table-b</span><span class="p">)</span>
		    <span class="p">(</span><span class="nb">format</span> <span class="s">"sed -i \"1d\" ./tba"</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">as-file-be-append</span> <span class="s">"./tba"</span> <span class="s">"./tbb"</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">shell-command</span> <span class="p">(</span><span class="nb">format</span> <span class="s">"mc put ./tbb %s"</span> <span class="nv">new-table</span><span class="p">)</span>
		   <span class="p">))</span>
</code></pre></div></div>

<p>测试：</p>

<p><img src="/assets/post_images/image-20240427223026110.png" alt="" /></p>

<h2 id="总结">总结</h2>

<p>通过此次实验，丰富了elisp对bash和minio的接口、熟悉了分布式环境minio的配置过程。不过第二次部署多节点minio失败略感遗憾。</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://min.io/docs/minio/linux/operations/install-deploy-manage/deploy-minio-single-node-single-drive.html">Deploy MinIO: Single-Node Single-Drive</a></li>
  <li>https://www.youtube.com/watch?v=zSKhvmWIO2k</li>
  <li>https://min.io/docs/minio/linux/operations/install-deploy-manage/deploy-minio-multi-node-multi-drive.html</li>
  <li>https://min.io/docs/minio/linux/operations/install-deploy-manage/deploy-minio-single-node-single-drive.html</li>
  <li>https://min.io/docs/minio/linux/index.html#procedure</li>
  <li>https://www.youtube.com/watch?v=fwoLEWYK-PE</li>
</ul>]]></content><author><name>甲与</name></author><summary type="html"><![CDATA[目标]]></summary></entry><entry><title type="html">关于我在配置hbase中的一些问题</title><link href="/%E5%85%B3%E4%BA%8E%E6%88%91%E5%9C%A8%E9%85%8D%E7%BD%AEhbase%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/" rel="alternate" type="text/html" title="关于我在配置hbase中的一些问题" /><published>2024-04-20T00:00:00+08:00</published><updated>2024-04-20T00:00:00+08:00</updated><id>/%E5%85%B3%E4%BA%8E%E6%88%91%E5%9C%A8%E9%85%8D%E7%BD%AEhbase%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98</id><content type="html" xml:base="/%E5%85%B3%E4%BA%8E%E6%88%91%E5%9C%A8%E9%85%8D%E7%BD%AEhbase%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"><![CDATA[<p>现在系统已经重装，所以再去探究错误的原因和处理方案已经意义不大。现在把当时的日志整理以下，用以备忘。</p>

<h3 id="问题一高cpu占用率">问题一：高CPU占用率</h3>

<p>当我把hbase启动失败的两个节点放置几天后查看，发现：</p>

<p><img src="/assets/post_images/image-20240417110959098.png" alt="" /></p>

<p>由于节点流量是有上限的，每个月100G。</p>

<p><img src="/assets/post_images/image-20240420095141618.png" alt="" />
😮‍💨😮‍💨😮‍💨</p>

<p>再对比一下性能消耗吧。</p>

<p><img src="/assets/post_images/image-20240420095613423.png" alt="" /></p>

<p>Hbase基于hadoop，而hadoop又是基于ssh协议进行文件传输，所以有时候top查看进程会发现sshd占用率高过100%。而minio就稳定得多。不过这种对比不能说明hadoop和minio的优劣，因为其中不包含只运行hadoop条件下的信息。不过hadoop还要连接到scala、Hive这些工具，进行csv到sql的文件转换，才能进行sql查询，相比之下，minio的确是要方便一些👍。</p>

<h3 id="问题二hosts文件自动更改">问题二：hosts文件自动更改</h3>

<p>当我启动zookeeper或重启之后，没过多久hosts文件自动清空并增加 <code class="language-plaintext highlighter-rouge">i a e</code>属性。</p>

<p>当然重启还有一种情况，那就是 <code class="language-plaintext highlighter-rouge">hosts</code> 文件恢复默认配置。</p>

<p>这可能和vps服务商的默认配置有关。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">lsattr file-name</code> 查看属性</li>
  <li><code class="language-plaintext highlighter-rouge">chattr +x file-name</code> 增加x属性</li>
  <li><code class="language-plaintext highlighter-rouge">chattr -x file-name</code> 减少x属性</li>
</ul>

<p>举例：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@J:/etc# lsattr hosts
<span class="nt">----ia--------e-----</span> hosts
</code></pre></div></div>
<p>i（immutable）：表示文件或目录是不可变的，即不能被修改、删除、重命名或链接。只有超级用户（root）可以修改或删除该文件或目录。</p>

<p>a（append-only）：表示文件只能向其末尾追加数据，不能修改或删除文件中已有的数据。只有超级用户（root）可以修改或删除该文件。</p>

<p>e（extend）：表示文件或目录使用了ACL（Access Control List，访问控制列表）来控制访问权限，允许对文件或目录设置更细粒度的权限控制。</p>

<p>对策：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@J:/etc# chattr -i hosts
root@J:/etc# chattr -a hosts
root@J:/etc# chattr -e hosts
root@J:/etc# lsattr hosts
-------------------- hosts
</code></pre></div></div>

<h3 id="问题三-节点丢失">问题三： 节点丢失</h3>

<p>jps查看节点发现只有jps本身，重启系统格式化namenode之后一切节点正常，但是持续运行一段时间会发生节点丢失问题，不过hadoop的webUI和命令行工具都能正常运行，9870端口也显示两个服务器在线，不明白是为什么。</p>

<h3 id="问题四命令行工具的使用">问题四：命令行工具的使用</h3>

<p>hadoop和zookeeper都提供了命令行的操作工具，用来创建和查看文件。</p>

<h4 id="hdfs-使用方法">hdfs 使用方法</h4>

<ul>
  <li>查看根目录
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hdfs dfs -ls /
</code></pre></div>    </div>
  </li>
  <li>创建文件夹
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hdfs dfs <span class="nt">-mkdir</span> /G
</code></pre></div>    </div>
  </li>
  <li>创建文件
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hdfs dfs <span class="nt">-touch</span> /G/test.txt
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="zookeeper-使用">zookeeper 使用</h4>

<p>在ZooKeeper中，你可以使用命令行客户端（<code class="language-plaintext highlighter-rouge">zkCli.sh</code>）进行交互式操作。以下是一些常用的ZooKeeper命令行操作：</p>

<ol>
  <li><strong>连接到ZooKeeper服务器</strong>：
    <ul>
      <li>使用以下命令连接到ZooKeeper服务器：<code class="language-plaintext highlighter-rouge">./zkCli.sh -server &lt;ZooKeeper服务器地址&gt;:&lt;端口号&gt;</code></li>
      <li>例如：<code class="language-plaintext highlighter-rouge">./zkCli.sh -server localhost:2181</code></li>
    </ul>
  </li>
  <li><strong>基本操作</strong>：
    <ul>
      <li><strong>创建节点</strong>：<code class="language-plaintext highlighter-rouge">create /path data</code>
        <ul>
          <li>例如：<code class="language-plaintext highlighter-rouge">create /myNode "Hello World"</code></li>
        </ul>
      </li>
      <li><strong>读取节点数据</strong>：<code class="language-plaintext highlighter-rouge">get /path</code>
        <ul>
          <li>例如：<code class="language-plaintext highlighter-rouge">get /myNode</code></li>
        </ul>
      </li>
      <li><strong>更新节点数据</strong>：<code class="language-plaintext highlighter-rouge">set /path data</code>
        <ul>
          <li>例如：<code class="language-plaintext highlighter-rouge">set /myNode "New Data"</code></li>
        </ul>
      </li>
      <li><strong>列出节点</strong>：<code class="language-plaintext highlighter-rouge">ls /path</code>
        <ul>
          <li>例如：<code class="language-plaintext highlighter-rouge">ls /</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>监视节点</strong>：
    <ul>
      <li><strong>设置监视</strong>：<code class="language-plaintext highlighter-rouge">get /path true</code>
        <ul>
          <li>该命令将监视给定节点的变化。如果节点数据发生变化，客户端将收到通知。</li>
        </ul>
      </li>
      <li><strong>取消监视</strong>：<code class="language-plaintext highlighter-rouge">rmr /path</code>
        <ul>
          <li>取消对节点的监视。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>删除节点</strong>：
    <ul>
      <li><strong>删除节点</strong>：<code class="language-plaintext highlighter-rouge">delete /path</code>
        <ul>
          <li>例如：<code class="language-plaintext highlighter-rouge">delete /myNode</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>帮助</strong>：
    <ul>
      <li><strong>获取帮助</strong>：<code class="language-plaintext highlighter-rouge">help</code>
        <ul>
          <li>可以查看ZooKeeper命令行客户端的帮助信息。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>退出命令行客户端</strong>：
    <ul>
      <li><strong>退出</strong>：<code class="language-plaintext highlighter-rouge">quit</code> 或 <code class="language-plaintext highlighter-rouge">exit</code>
        <ul>
          <li>用于退出ZooKeeper命令行客户端。</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>]]></content><author><name>甲与</name></author><summary type="html"><![CDATA[现在系统已经重装，所以再去探究错误的原因和处理方案已经意义不大。现在把当时的日志整理以下，用以备忘。]]></summary></entry><entry><title type="html">如何使用 minio 进行数据库查询</title><link href="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-minio-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2/" rel="alternate" type="text/html" title="如何使用 minio 进行数据库查询" /><published>2024-04-20T00:00:00+08:00</published><updated>2024-04-20T00:00:00+08:00</updated><id>/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20minio%20%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2</id><content type="html" xml:base="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-minio-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2/"><![CDATA[<p>minio 提供了对s3存储对象的sql操作。一方面为了处理实验报告，另一方面也是为了增加可以使用的工具数量，所以需要增进对于<code class="language-plaintext highlighter-rouge">mc sql</code>的理解。</p>

<p>本篇博客处理以下几个问题：</p>

<ul>
  <li>s3 是什么？</li>
  <li>minio 上的何种对象可以视为 s3 对象？</li>
  <li>如何操作 S3 对象？</li>
  <li>如何把这种查询封装到emacs中？</li>
</ul>

<h2 id="s3-是什么"><code class="language-plaintext highlighter-rouge">s3</code> 是什么？</h2>

<blockquote>
  <p>Amazon Simple Storage Service（Amazon S3）是一种对象存储服务，提供行业领先的可扩展性、数据可用性、安全性和性能。各种规模和行业的客户都可以使用 Amazon S3 存储和保护任意数量的数据，用于数据湖、网站、移动应用程序、备份和恢复、归档、企业应用程序、IoT 设备和大数据分析。Amazon S3 提供了管理功能，使您可以优化、组织和配置对数据的访问，以满足您的特定业务、组织和合规性要求。</p>
</blockquote>

<p>所以，S3, 全称Simple Storage Service，直译简单存储服务。那么 <code class="language-plaintext highlighter-rouge">S3 Object</code> 就是简单存储服务对象。</p>

<p>另外需要注意，s3o 文件一般要下载到本地进行处理，然后上传进行覆盖。</p>

<h2 id="可以把minio上的何种对象视为s3对象">可以把minio上的何种对象视为<code class="language-plaintext highlighter-rouge">s3对象</code>？</h2>

<p><code class="language-plaintext highlighter-rouge">mc sql --help</code> 看看文档。</p>

<p><img src="/assets/post_images/image-20240420090054853.png" alt="" /></p>

<p>所以，可以把<code class="language-plaintext highlighter-rouge">csv</code>文件理解为一种<code class="language-plaintext highlighter-rouge">s3 Object</code>的实例。确实足够简单😊。</p>

<p>那只要把bash命令封装到elisp中就可以了。不过在这之前要先熟悉一下 csv文件的基本操作。</p>

<h2 id="可以如何操作s3">可以如何操作S3？</h2>

<p>打开 <code class="language-plaintext highlighter-rouge">Libreoffice</code> 创建几个数据，</p>

<p><img src="/assets/post_images/image-20240420090847909.png" alt="" /></p>

<p>按默认格式存储为csv文件 <code class="language-plaintext highlighter-rouge">stu.csv</code>，打开emacs看看：</p>

<p><img src="/assets/post_images/image-20240420091006763.png" alt="" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>mc mb minio-server/csv
<span class="nv">$ </span>mc put stu.csv minio-server/csv
</code></pre></div></div>

<h3 id="sql-操作">sql 操作</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mc sql --recursive --query "select * from S3Object" minio-server/csv/stu.csv
张三,100
李四,50
王五,60
</code></pre></div></div>

<p>好棒👍。来增加几个查询条件看看吧。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$mc</span> sql <span class="nt">--recursive</span> <span class="nt">--query</span> <span class="s2">"select * from S3Object where </span><span class="se">\"</span><span class="s2">成绩</span><span class="se">\"</span><span class="s2">=100"</span> minio-server/csv/stu.csv
张三,100
<span class="nv">$mc</span> sql <span class="nt">--recursive</span> <span class="nt">--query</span> <span class="s2">"select * from S3Object where </span><span class="se">\"</span><span class="s2">成绩</span><span class="se">\"</span><span class="s2">&gt;=60"</span> minio-server/csv/stu.csv
张三,100
王五,60
</code></pre></div></div>

<p>漂亮🎉。</p>

<h2 id="如何把mc的sql操作封装到emacs中">如何把mc的sql操作封装到emacs中？</h2>

<p>按照主语表达法，<code class="language-plaintext highlighter-rouge">(as-s3o-be-sq file-name sql-sentence)</code> 就可以获取数据了。其中<code class="language-plaintext highlighter-rouge">sq</code>的意义是，<code class="language-plaintext highlighter-rouge">structured query</code>，因为<code class="language-plaintext highlighter-rouge">sql</code>的全称是：<code class="language-plaintext highlighter-rouge">structured query language</code>。（所以实际上说<code class="language-plaintext highlighter-rouge">使用sql语言</code> 这种说法是不正确的，什么是<code class="language-plaintext highlighter-rouge">language语言</code>呢？）不过这样的限制也很明显，最多只能查询一个表，所以表和表的连接基本上就不用考虑了。</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">(</span><span class="nb">defun</span> <span class="nv">as-s3o-be-sq</span> <span class="p">(</span><span class="nv">s3o</span> <span class="nv">sq</span><span class="p">)</span>
      <span class="s">"make a sq query to s3o on minio server. The input of s3o should be a string path to s3o, and sq should be a string of sql. This function will return query result as string"</span>
      <span class="p">(</span><span class="nv">shell-command</span> <span class="p">(</span><span class="nb">format</span> <span class="s">"mc sql --recursive --query \"%s\" %s"</span> <span class="nv">s3o</span> <span class="nv">sq</span><span class="p">)))</span>
      
</code></pre></div></div>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="nv">as-s3o-be-sq</span> <span class="s">"select * from S3Object"</span> <span class="s">"minio-server/csv/stu.csv"</span><span class="p">)</span>
</code></pre></div></div>

<p>结果<strong>返回0 而Message 中则返回查询结果</strong>。</p>

<p>嗯……<code class="language-plaintext highlighter-rouge">shell-command</code> 会返回退出码，<code class="language-plaintext highlighter-rouge">shell-command-to-string</code> 才能获得<code class="language-plaintext highlighter-rouge">shell</code> 的输出结果。</p>

<p>改一下：</p>

<p><img src="/assets/post_images/image-20240420094006548.png" alt="" /></p>

<p>完美🎉🎉。</p>

<h2 id="参考">参考</h2>

<ul>
  <li>https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/userguide/Welcome.html</li>
</ul>]]></content><author><name>甲与</name></author><category term="minio" /><summary type="html"><![CDATA[minio 提供了对s3存储对象的sql操作。一方面为了处理实验报告，另一方面也是为了增加可以使用的工具数量，所以需要增进对于mc sql的理解。]]></summary></entry><entry><title type="html">Minio 的配置过程</title><link href="/minio-%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/" rel="alternate" type="text/html" title="Minio 的配置过程" /><published>2024-04-19T00:00:00+08:00</published><updated>2024-04-19T00:00:00+08:00</updated><id>/minio%20%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B</id><content type="html" xml:base="/minio-%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"><![CDATA[<p>如果只是想用分布式文件系统，其实hadoop也可以，但在配置hbase的过程中出现的节点丢失和高cpu占用率问题还是让我想尝试其它的分布式框架。这次记录minio的配置过程。</p>

<h2 id="介绍">介绍</h2>

<p><a href="https://min.io">Minio</a>是一个开源的分布式对象存储服务，专注于高性能、高可用性和轻量级的设计，有以下两个基本特征：</p>

<ol>
  <li>
    <p><strong>对象存储服务</strong>：MinIO 是一个对象存储服务，它允许用户以类似文件系统的方式存储和检索大规模数据。这种存储方式适用于云原生应用程序、大数据分析、备份和归档等场景。</p>
  </li>
  <li>
    <p><strong>分布式架构</strong>：MinIO 使用分布式架构，可以在多个节点上并行存储和检索数据。这种架构可以提供高扩展性和高性能，使得 MinIO 能够应对大规模数据存储的需求。</p>
  </li>
</ol>

<h2 id="步骤">步骤</h2>

<p>环境 ubuntu20.04</p>

<ol>
  <li>安装</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://dl.min.io/server/minio/release/linux-amd64/archive/minio_20240406052602.0.0_amd64.deb <span class="nt">-O</span> minio.deb
<span class="nb">sudo </span>dpkg <span class="nt">-i</span> minio.deb

<span class="nb">mkdir</span> /data
<span class="nb">mkdir</span> /data/drive1
<span class="nb">mkdir</span> /data/drive2
<span class="nb">mkdir</span> /data/drive3
<span class="nb">mkdir</span> /data/drive4
</code></pre></div></div>

<p>配置:</p>

<ul>
  <li>在<code class="language-plaintext highlighter-rouge">/etc/hosts</code> 中
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip_1 N1
ip_2 N2
</code></pre></div>    </div>
  </li>
  <li>在<code class="language-plaintext highlighter-rouge">~/.bashrc</code>中</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">MINIO_ACCESS_KEY</span><span class="o">=</span>minioadmin
<span class="nb">export </span><span class="nv">MINIO_SECRET_KEY</span><span class="o">=</span>minioadmin
<span class="nb">export </span><span class="nv">CI</span><span class="o">=</span><span class="nb">true
export </span><span class="nv">MINIO_CI_CD</span><span class="o">=</span><span class="nb">true</span>
</code></pre></div></div>

<p>启动:</p>

<p>在两个节点中：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">nohup </span>minio server http://N<span class="o">{</span>1..2<span class="o">}</span>:9000/data/drive<span class="o">{</span>1...4<span class="o">}</span> &amp;
</code></pre></div></div>

<p>于命令行中访问文件 <code class="language-plaintext highlighter-rouge">nohup.out</code> 查看 <code class="language-plaintext highlighter-rouge">webUI</code> 端口进行访问即可。</p>

<h3 id="命令行端-mc">命令行端 MC</h3>

<p>安装</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://dl.min.io/client/mc/release/linux-amd64/mc
<span class="nb">chmod</span> +x mc
<span class="nb">sudo mv </span>mc /usr/local/bin/mc
</code></pre></div></div>

<p>设置用户</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc <span class="nb">alias set local </span>http://your_ip:9000 minioadmin minioadmin
</code></pre></div></div>

<p>操作：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc <span class="nt">--help</span> 查看命令帮助
</code></pre></div></div>

<p>基本的路径格式是 <code class="language-plaintext highlighter-rouge">alias 设置的登录名+桶名+对象路径</code> 。</p>

<p>创建桶</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc mb minio-server/test
</code></pre></div></div>

<p>比如查看<code class="language-plaintext highlighter-rouge">b1</code> 目录下的文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc <span class="nb">ls </span>minio-server/test
</code></pre></div></div>

<p>再比如上传文件</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc put test.txt minio-server/test
</code></pre></div></div>

<p>下载文件</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mc get minio-server/test/test.txt ./
</code></pre></div></div>

<p>其它</p>

<table>
  <thead>
    <tr>
      <th>命令</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">alias</code></td>
      <td>在配置文件中管理服务器凭据</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">admin</code></td>
      <td>管理MinIO服务器</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anonymous</code></td>
      <td>管理对存储桶和对象的匿名访问</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">batch</code></td>
      <td>管理批处理作业</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cp</code></td>
      <td>复制对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cat</code></td>
      <td>显示对象内容</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">diff</code></td>
      <td>列出两个存储桶之间对象名称、大小和日期的差异</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">du</code></td>
      <td>递归总结磁盘使用情况</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">encrypt</code></td>
      <td>管理存储桶加密配置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">event</code></td>
      <td>管理对象通知</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">find</code></td>
      <td>搜索对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">get</code></td>
      <td>将S3对象获取到本地</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">head</code></td>
      <td>显示对象的前n行</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ilm</code></td>
      <td>管理存储桶生命周期</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">idp</code></td>
      <td>管理MinIO身份提供者服务器配置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">license</code></td>
      <td>许可证相关命令</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">legalhold</code></td>
      <td>管理对象的法律保留</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ls</code></td>
      <td>列出存储桶和对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">mb</code></td>
      <td>创建一个存储桶</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">mv</code></td>
      <td>移动对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">mirror</code></td>
      <td>将对象同步到远程站点</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">od</code></td>
      <td>测量单个流上传和下载</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ping</code></td>
      <td>执行存活性检查</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pipe</code></td>
      <td>将标准输入流传输到对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">put</code></td>
      <td>将对象上传到存储桶</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">quota</code></td>
      <td>管理存储桶配额</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rm</code></td>
      <td>删除对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">retention</code></td>
      <td>为对象设置保留期</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rb</code></td>
      <td>删除一个存储桶</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">replicate</code></td>
      <td>配置服务器端存储桶复制</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ready</code></td>
      <td>检查集群是否就绪</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sql</code></td>
      <td>在对象上运行SQL查询</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">stat</code></td>
      <td>显示对象元数据</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">support</code></td>
      <td>支持相关命令</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">share</code></td>
      <td>生成临时访问对象的URL</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">tree</code></td>
      <td>以树状格式列出存储桶和对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">tag</code></td>
      <td>管理存储桶和对象的标签</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">undo</code></td>
      <td>撤销PUT/DELETE操作</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">update</code></td>
      <td>将mc更新到最新版本</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">version</code></td>
      <td>管理存储桶版本控制</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">watch</code></td>
      <td>监听对象通知事件</td>
    </tr>
  </tbody>
</table>

<h2 id="参考">参考</h2>

<ul>
  <li>https://www.youtube.com/watch?v=zSKhvmWIO2k</li>
  <li>https://min.io/docs/minio/linux/operations/install-deploy-manage/deploy-minio-multi-node-multi-drive.html</li>
  <li>https://min.io/docs/minio/linux/operations/install-deploy-manage/deploy-minio-single-node-single-drive.html</li>
  <li>https://min.io/docs/minio/linux/index.html#procedure</li>
</ul>]]></content><author><name>甲与</name></author><category term="配置" /><category term="minio" /><summary type="html"><![CDATA[如果只是想用分布式文件系统，其实hadoop也可以，但在配置hbase的过程中出现的节点丢失和高cpu占用率问题还是让我想尝试其它的分布式框架。这次记录minio的配置过程。]]></summary></entry><entry><title type="html">Segfault简介</title><link href="/segfault%E7%AE%80%E4%BB%8B/" rel="alternate" type="text/html" title="Segfault简介" /><published>2024-04-19T00:00:00+08:00</published><updated>2024-04-19T00:00:00+08:00</updated><id>/segfault%E7%AE%80%E4%BB%8B</id><content type="html" xml:base="/segfault%E7%AE%80%E4%BB%8B/"><![CDATA[<p>记录一个可以免费使用vps的网站，<a href="https://shell.segfault.net">segfault</a>。</p>

<p>直接登录即可获得一个vps，会给出一个<code class="language-plaintext highlighter-rouge">Secret</code>用于再次登录。</p>

<p><img src="/assets/post_images/image-20240420080409217.png" alt="" /></p>
<h2 id="限制">限制</h2>

<p>当然有一定限制：</p>

<p><img src="/assets/post_images/image-20240420080800998.png" alt="" /></p>

<p>申请的时候等60秒，这个无所谓。</p>

<p>网络流量受限制，但是实际上登录后的下载速度并不慢。</p>

<p>cpu受限，但是对于运行emacs之类小组件而言的没有什么问题，可用外存估计不过1G，因为之前单单尝试<code class="language-plaintext highlighter-rouge">sudo update</code> <code class="language-plaintext highlighter-rouge">sudo upgrade</code> 磁盘空间就满了。</p>

<p>可能被自动封禁，以及登出后服务器关闭，所以不适合需要持续化存储的作业。</p>

<p>根据 <code class="language-plaintext highlighter-rouge">https://thc.org/sf/token</code> 的说法，<code class="language-plaintext highlighter-rouge">token</code> 是非卖品，你需要访问以下telegram 频道：</p>

<p><img src="assets/post_images/image-20240420081410897.png" alt="" /></p>

<p>然后用符合下述标准的理由提出申请：</p>

<ul>
  <li>参与讨论。</li>
  <li>帮助管理员/系统管理员；管理群聊。</li>
  <li>分享你的想法、评论和顾虑。</li>
  <li>寻找漏洞。</li>
  <li>为社区做贡献的项目。</li>
  <li>新颖且令人兴奋的项目。</li>
  <li>拯救世界。</li>
  <li>黑客行动主义和IT安全研究。</li>
</ul>

<h2 id="命令行登录">命令行登录</h2>

<p>除了在网页端登录之外，还可以命令行登录。</p>

<p><img src="/assets/post_images/image-20240420082946802.png" alt="" /></p>

<p>在本地的<code class="language-plaintext highlighter-rouge">~/.ssh</code> 目录下，你需要把<code class="language-plaintext highlighter-rouge">openssh</code> 的私匙复制到<code class="language-plaintext highlighter-rouge">id_sf-adm-segfault-net</code> 中，把<code class="language-plaintext highlighter-rouge">ssh_config</code> 内容复制到 <code class="language-plaintext highlighter-rouge">config</code> 文件中。然后通过 <code class="language-plaintext highlighter-rouge">ssh server-name</code> 即可登录。当然也有 sftp 和 scp 命令用于传输文件。<code class="language-plaintext highlighter-rouge">scp</code> 的用法是：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp &lt;server-name&gt;:/path/to/file /local/path
</code></pre></div></div>

<h2 id="关于外部端口访问">关于外部端口访问</h2>

<p><code class="language-plaintext highlighter-rouge">segfault</code>的vps 默认不提供公网ip，所以是不能直接从外部计算机访问的，要访问需要用特定方式打开端口，在这里给出一种实现方案：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Request a random public TCP port:</span>
curl sf/port
<span class="nb">echo</span> <span class="s2">"Your public IP:PORT is </span><span class="si">$(</span><span class="nb">cat</span> /config/self/reverse_ip<span class="si">)</span><span class="s2">:</span><span class="si">$(</span><span class="nb">cat</span> /config/self/reverse_port<span class="si">)</span><span class="s2">"</span>
</code></pre></div></div>

<p>你的tcp端口和ip会存放在 <code class="language-plaintext highlighter-rouge">/config/self</code> 目录下的 <code class="language-plaintext highlighter-rouge">reverse_ip</code> 和 <code class="language-plaintext highlighter-rouge">reverse_port</code> 文件中。在这里测试<code class="language-plaintext highlighter-rouge">trilium</code> 或者 <code class="language-plaintext highlighter-rouge">emacs</code> 的 <code class="language-plaintext highlighter-rouge">elnode</code> 或许会很有趣😄。</p>

<h2 id="参考">参考</h2>

<ul>
  <li>https://www.thc.org/sf/faq/</li>
  <li>https://github.com/hackerschoice/thc-tips-tricks-hacks-cheat-sheet#tunnel</li>
</ul>]]></content><author><name>甲与</name></author><category term="简介" /><summary type="html"><![CDATA[记录一个可以免费使用vps的网站，segfault。]]></summary></entry><entry><title type="html">Hbase 配置 (失败)</title><link href="/hbase-%E9%85%8D%E7%BD%AE-(%E5%A4%B1%E8%B4%A5)/" rel="alternate" type="text/html" title="Hbase 配置 (失败)" /><published>2024-04-15T00:00:00+08:00</published><updated>2024-04-15T00:00:00+08:00</updated><id>/hbase%20%E9%85%8D%E7%BD%AE%20(%E5%A4%B1%E8%B4%A5)</id><content type="html" xml:base="/hbase-%E9%85%8D%E7%BD%AE-(%E5%A4%B1%E8%B4%A5)/"><![CDATA[<h2 id="目标">目标</h2>

<p>熟悉hbase配置的基本流程</p>

<h2 id="集群部署">集群部署</h2>

<h3 id="环境说明">环境说明</h3>

<p>两台ubuntu20.04 VPS。</p>

<h3 id="hadoop">hadoop</h3>

<ol>
  <li>在两个vps中用 <code class="language-plaintext highlighter-rouge">ssh-keygen -t rsa</code> 命令生成密匙文件，复制到另一个vps的 <code class="language-plaintext highlighter-rouge">~/.ssh/authorized_keys</code> 中，实现免密登录。</li>
  <li>在<code class="language-plaintext highlighter-rouge">/etc/hosts</code> 中修改ip-主机名映射关系。在<code class="language-plaintext highlighter-rouge">/etc/hostname</code>文件中修改主机名，<code class="language-plaintext highlighter-rouge">reboot</code> 使主机名修改生效。</li>
  <li>下载<a href="https://jdk.java.net/java-se-ri/11">jdk-11</a>并解压，增加JAVA_HOME 到 <code class="language-plaintext highlighter-rouge">~/.bashrc</code> 文件中，用<code class="language-plaintext highlighter-rouge">source</code> 命令使之生效。</li>
  <li>从官网下载<a href="https://hadoop.apache.org/releases.html">hadoop-3.9.2</a>版本并解压。</li>
</ol>

<ul>
  <li>
    <p>修改文件</p>
  </li>
  <li>
    <p>hadoop-env.sh 增加内容</p>
  </li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">JAVA_HOME</span><span class="o">=</span>/root/src/jdk-11
<span class="nv">HDFS_DATANODE_USER</span><span class="o">=</span>root
<span class="nv">HDFS_NAMENODE_USER</span><span class="o">=</span>root
<span class="nv">HDFS_SECONDARYNAMENODE_USER</span><span class="o">=</span>root
</code></pre></div></div>

<ul>
  <li>core-site.xml 修改配置</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;configuration&gt;</span>
	<span class="nt">&lt;property&gt;</span>
		<span class="nt">&lt;name&gt;</span>fs.defaultFS<span class="nt">&lt;/name&gt;</span>
		<span class="nt">&lt;value&gt;</span>hdfs://G:9000<span class="nt">&lt;/value&gt;</span>
	<span class="nt">&lt;/property&gt;</span>
	<span class="nt">&lt;property&gt;</span>
		<span class="nt">&lt;name&gt;</span>hadoop.tmp.dir<span class="nt">&lt;/name&gt;</span>
		<span class="nt">&lt;value&gt;</span>/root/data/tmp<span class="nt">&lt;/value&gt;</span>
	<span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</code></pre></div></div>

<ul>
  <li>hdfs-site.xml 修改配置</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;configuration&gt;</span>
	<span class="nt">&lt;property&gt;</span>
		<span class="nt">&lt;name&gt;</span>dfs.namenode.name.dir<span class="nt">&lt;/name&gt;</span>
		<span class="nt">&lt;value&gt;</span>/root/data/namenode<span class="nt">&lt;/value&gt;</span>
	<span class="nt">&lt;/property&gt;</span>
	
	<span class="nt">&lt;property&gt;</span>
	<span class="nt">&lt;name&gt;</span>dfs.datanode.data.dir<span class="nt">&lt;/name&gt;</span>
		<span class="nt">&lt;value&gt;</span>/root/data/datanode<span class="nt">&lt;/value&gt;</span>
	<span class="nt">&lt;/property&gt;</span>
	<span class="nt">&lt;property&gt;</span>
	<span class="nt">&lt;name&gt;</span>dfs.replication<span class="nt">&lt;/name&gt;</span>
		<span class="nt">&lt;value&gt;</span>2<span class="nt">&lt;/value&gt;</span>
	<span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</code></pre></div></div>

<ul>
  <li>workers 修改配置</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>G
J
</code></pre></div></div>

<p>用<code class="language-plaintext highlighter-rouge">scp</code> 命令同步VPS文件修改。</p>

<ol>
  <li>
    <p>格式化： <code class="language-plaintext highlighter-rouge">/path/to/hadoop/bin/hdfs namenode -format</code></p>
  </li>
  <li>
    <p>启动hdfs：<code class="language-plaintext highlighter-rouge">/path/to/hadoop/sbin/start-dfs.sh</code>，访问9870端口查看hdfs是否正常启动。</p>
  </li>
</ol>

<p><img src="/assets/post_images/Pasted image 20240414073338.png" alt="123" /></p>
<ol>
  <li>启动yarn：</li>
</ol>

<ul>
  <li>hadoop-env.sh 增加内容：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">YARN_RESOURCEMANAGER_USER</span><span class="o">=</span>root
<span class="nb">export </span><span class="nv">YARN_NODEMANAGER_USER</span><span class="o">=</span>root
</code></pre></div></div>

<ul>
  <li>yarn-site.xml 增加内容：</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;property&gt;</span>
	<span class="nt">&lt;name&gt;</span>yarn.resourcemanager.hostname<span class="nt">&lt;/name&gt;</span>
	<span class="nt">&lt;value&gt;</span>G<span class="nt">&lt;/value&gt;</span>
<span class="nt">&lt;/property&gt;</span>
</code></pre></div></div>

<ul>
  <li>执行命令：<code class="language-plaintext highlighter-rouge">/path/to/hadoop/sbin/start-yarn.sh</code>，访问8088端口查看yarn是否正常工作：</li>
</ul>

<p><img src="/assets/post_images/Pasted image 20240414073731.png" alt="123" />
可以看到，两个节点正常工作。</p>

<h3 id="zookeeper">zookeeper</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">weget</code>命令从官网下载<a href="https://zookeeper.apache.org/releases.html">zookeeper-3.9.2</a>并解压。</li>
  <li>修改配置文件：</li>
</ol>

<ul>
  <li>zoo.cfg in vps1</li>
</ul>

<pre><code class="language-cfg">tickTime=2000
dataDir=/var/lib/zookeeper
clientPort=2181
initLimit=5
syncLimit=2
server.1=0.0.0.0:2888:3888
server.2=J:2888:3888
</code></pre>
<ul>
  <li>zoo.cfg in vps2</li>
</ul>

<pre><code class="language-cfg">tickTime=2000
dataDir=/var/lib/zookeeper
clientPort=2181
initLimit=5
syncLimit=2
server.1=G:2888:3888
server.2=0.0.0.0:2888:3888
</code></pre>
<ol>
  <li>在两个vps分别执行<code class="language-plaintext highlighter-rouge">/path/to/zookeeper/bin/zkServer.sh start</code> 启动zookeeper。</li>
  <li>执行<code class="language-plaintext highlighter-rouge">/path/to/zookeeper/bin/zkCli.sh -server 127.0.0.1:2181</code> <code class="language-plaintext highlighter-rouge">ls /</code> 确保 zookeeper 工作。
    <h3 id="hbase">hbase</h3>
  </li>
  <li>官网下载<a href="https://hbase.apache.org/downloads.html">hbase-2.5.8</a>并解压。</li>
  <li>修改文件
    <ul>
      <li>在hbase-site.xml中
```xml</li>
    </ul>
  </li>
</ol>
<property>
    <name>hbase.cluster.distributed</name>
    <value>true</value>
  </property>
<property>
    <name>hbase.tmp.dir</name>
    <value>/root/data/hbase/tmp</value>
  </property>
<property>
    <name>hbase.unsafe.stream.capability.enforce</name>
    <value>false</value>
  </property>
<property>
    <name>hbase.zookeeper.quorum</name>
    <value>G,J</value>
  </property>
<property>
    <name>hbase.zookeeper.property.dataDir</name>
    <value>/root/data/zookeeper</value>
  </property>
<property>
    <name>hbase.zookeeper.property.clientPort</name>
    <value>2181</value>
  </property>
<property>
    <name>hbase.master.info.port</name>
    <value>16010</value>
  </property>
<p>&lt;/configuration&gt;</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
- 在conf/regionservers文件中增加：
</code></pre></div></div>
<p>G
J</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
- 在conf/文件夹下新建文件backup-masters，内容为：
</code></pre></div></div>
<p>J</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 替换hadoop-jar包
```bash
rm /path/to/hbase/lib/hadoop*.jar
find /path/to/hadoop/share/hadoop -name "hadoop*.jar" | xargs -i cp {} /path/to/hbase/lib/
</code></pre></div></div>

<ul>
  <li>scp命令同步文件
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp /path/to/hbase root@J:/path/to/habase
</code></pre></div>    </div>
  </li>
  <li>链接文件
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ln</span> <span class="nt">-s</span> /path/to/hadoop/etc/hadoop/core-site.xml  /path/to/hbase/conf/core-site.xml
<span class="nb">ln</span> <span class="nt">-s</span> /path/to/hadoop/etc/hadoop/hdfs-site.xml  /path/to/hbase/conf/hdfs-site.xml
</code></pre></div>    </div>
    <ol>
      <li>启动服务：<code class="language-plaintext highlighter-rouge">/path/to/hbase/bin/start-hbase.sh</code></li>
      <li>访问端口：16010查看hbase是否正常工作。</li>
    </ol>
  </li>
</ul>

<p><img src="/assets/post_images/20240414-b.png" alt="" /></p>
<ul>
  <li>jps查看系统状态：</li>
</ul>

<p>从节点：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@J:~# jps
1314 DataNode
1843 QuorumPeerMain
1597 NodeManager
7454 Jps
</code></pre></div></div>
<p>主节点：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@G:~/src/hbase-2.5.8/conf# jps
11009 Jps
1330 NameNode
2467 SecondaryNameNode
3285 QuorumPeerMain
2845 NodeManager
2670 ResourceManager
</code></pre></div></div>

<p>问题：主节点Hmaster 和 HReigonServer 进程丢失，从节点HreigonServer 丢失。</p>

<p>在 Hbase中输入指令，只返回错误：</p>

<p><img src="/assets/post_images/20240414-c.png" alt="" /></p>

<h2 id="总结">总结</h2>

<ul>
  <li>目前尝试过的解决策略包括：</li>
</ul>

<ol>
  <li><a href="https://segmentfault.com/q/1010000000606670">全分布式HBase启动后HMaster和HRegionServer自动消失</a> ：删除<code class="language-plaintext highlighter-rouge">/etc/hosts</code> 中的127.0.0.1行，失败。</li>
  <li><a href="https://blog.csdn.net/weixin_34238633/article/details/91907325">regionserver.HRegionServer: Failed construction RegionServer</a>：复制<code class="language-plaintext highlighter-rouge">/path/to/hbase/lib/client-facing-thirdparty</code> 下的 <code class="language-plaintext highlighter-rouge">htrace-core-3.1.0</code> 到 <code class="language-plaintext highlighter-rouge">/path/to/hbase/lib</code> 目录中，失败。</li>
</ol>

<p>hbase 的日志文件<code class="language-plaintext highlighter-rouge">hbase-root-master-G.log</code> 报错如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2024-04-14T14:47:17,496 ERROR [main] regionserver.HRegionServer: Failed construction RegionServer
java.lang.StackOverflowError: null
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1302) ~[?:?]
        at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:439) ~[?:?]
        at java.util.concurrent.LinkedBlockingDeque.offerLast(LinkedBlockingDeque.java:355) ~[?:?]
        at java.util.concurrent.LinkedBlockingDeque.addLast(LinkedBlockingDeque.java:325) ~[?:?]
</code></pre></div></div>

<ul>
  <li>进一步解决策略</li>
</ul>

<p>关于hbase和zookeeper，由于已经通过shell和web界面验证过，应无配置问题。有可能是hadoop、hbase和zookeeper版本之间的不兼容，或者仍然存在habase的配置错误。一方面可以在查询资料，重新检验配置文件，另一方面可以考虑伪分布式来继续实验。</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://blog.csdn.net/qq_27525611/article/details/108114893">CSDN: Hadoop完整搭建过程（四）：完全分布模式（服务器）</a></li>
  <li><a href="https://zookeeper.apache.org/doc/current/zookeeperStarted.html">ZooKeeper Getting Started Guide</a></li>
  <li><a href="https://stackoverflow.com/questions/30940981/zookeeper-error-cannot-open-channel-to-x-at-election-address">Zookeeper error: Cannot open channel to X at election address</a></li>
  <li><a href="https://hbase.apache.org/book.html">Hbase refference guide 2.4:Fully Distributed for Production</a></li>
  <li><a href="https://segmentfault.com/q/1010000000606670">全分布式HBase启动后HMaster和HRegionServer自动消失</a></li>
  <li><a href="https://blog.csdn.net/weixin_34238633/article/details/91907325">regionserver.HRegionServer: Failed construction RegionServer</a></li>
</ul>]]></content><author><name>甲与</name></author><category term="失败" /><category term="分布式" /><summary type="html"><![CDATA[目标]]></summary></entry><entry><title type="html">Tlaplus：操作符和函数</title><link href="/tlaplus-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%87%BD%E6%95%B0/" rel="alternate" type="text/html" title="Tlaplus：操作符和函数" /><published>2024-04-12T00:00:00+08:00</published><updated>2024-04-12T00:00:00+08:00</updated><id>/tlaplus%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%87%BD%E6%95%B0</id><content type="html" xml:base="/tlaplus-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%87%BD%E6%95%B0/"><![CDATA[<p>了解一下 tlaplus 的操作符和函数。</p>

<h2 id="tla-的变量">TLA+ 的变量</h2>
<h3 id="q1tla-有什么自定义操作符">Q1：TLA+ 有什么自定义操作符？</h3>

<ul>
  <li>我比较感兴趣的是用户自定义操作符：</li>
</ul>

<pre><code class="language-tla+">set ++ elem == set \union {elem}
set -- elem == set \ {elem}
&gt;&gt; {1, 2} ++ 3
{1, 2, 3}
&gt;&gt; {1, 2} – 2
{1}
</code></pre>

<p>现在可不可以吧fovis之类的定义了呢？</p>

<pre><code class="language-tla+">mio \ifvp vio \da ilio == IFVP(mio, vio, ilio) 
</code></pre>

<p>好像不可以。</p>

<pre><code class="language-tla+">mio  vio -da ilio == IFVP(mio, vio, ilio) 
</code></pre>

<p>麻烦了。只能定义两元运算符。</p>

<p>现在定义一下元素的流动吧：</p>

<p>一个元素从fovis 到 fogim怎么处理？</p>

<p>现有的表达方式是： <code class="language-plaintext highlighter-rouge">mio \ elem; vio \ elem; ilio \union elem;</code></p>

<p>而我期待更加简洁的表达：<code class="language-plaintext highlighter-rouge">elem rfvffgd moko</code></p>

<p>整理一个表格吧：</p>

<table>
  <thead>
    <tr>
      <th>ASCii</th>
      <th>图像</th>
      <th>意义</th>
      <th>ASCii</th>
      <th>符号</th>
      <th>意义</th>
      <th>ASCII</th>
      <th>符号</th>
      <th>意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">++</code></td>
      <td>$++$</td>
      <td>fofos</td>
      <td> </td>
      <td>\(\sqcap\)</td>
      <td> </td>
      <td> </td>
      <td>\(\sim\)</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--</code></td>
      <td>$–$</td>
      <td>focos</td>
      <td> </td>
      <td>\(\sqcup\)</td>
      <td> </td>
      <td> </td>
      <td>\(\simeq\)</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">**</code></td>
      <td>$**$</td>
      <td> </td>
      <td> </td>
      <td>\(\odot\)</td>
      <td> </td>
      <td> </td>
      <td>\(\approx\)</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">//</code></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>\(\prec\)</td>
      <td> </td>
      <td> </td>
      <td>\(\cong\)</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">^^</code></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>\(\preceq\)</td>
      <td> </td>
      <td> </td>
      <td>\(\doteq\)</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;&amp;</code></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>\(\succ\)</td>
      <td> </td>
      <td> </td>
      <td>\(\asymp\)</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">%%</code></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>\(\succeq\)</td>
      <td> </td>
      <td> </td>
      <td>\(\bigcirc\)</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">@@</code></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>\(\ll\)</td>
      <td> </td>
      <td> </td>
      <td>\(\propto\)</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">##</code></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>\(\gg\)</td>
      <td> </td>
      <td> </td>
      <td>\(\wr\)</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">$$</code></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>\(\sqsubset\)</td>
      <td> </td>
      <td> </td>
      <td>\(\uplus\)</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">!!</code></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>\(\sqsupset\)</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">??</code></td>
      <td> </td>
      <td>判断维解状态</td>
      <td> </td>
      <td>\(\subset\)</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">$</code></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>\(\supset\)</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">\bullet</code></td>
      <td>$\bullet$</td>
      <td> </td>
      <td> </td>
      <td>\(|-\)</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">\star</code></td>
      <td>$\star$</td>
      <td> </td>
      <td> </td>
      <td>\(-|\)</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">\|</code></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>\(=|\)</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;</code></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>\(|=\)</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>如果考虑到维解总要在有意义的某个集合上进行计算。那么实际上，Mio就应该具有两个集合。</p>

\[oso = [rio \mapsto \{1, 2, 5\}, fao \mapsto \{1, 2 ,3, 4\}]\]

<p>当两个集合相互作用的时候就会产生维解。</p>

<p>比如说：</p>

<p>\(oso_a = [rio \mapsto \{1, 2, 5\}, fao \mapsto \{1, 2 ,3, 4\}]\)
\(oso_b = [rio \mapsto \{1, 2, 6\}, fao \mapsto \{1, 2 ,3, 4\}]\)</p>

<p>在 fao相同的意义上，a和b可以进行维解。</p>

<p>$Mok(oso_a, oso_b) \triangleq [mio \mapsto {1, 2, 5}, vio \mapsto {1, 2, 6}, ilio \mapsto {1, 2, 3, 4}]$</p>

<p>那么我怎么规定维解的意义呢？</p>

<p>判断是否为某种状态？</p>

<p>选取某种区域的元素？</p>

<p>还是说在进入集合之前先从逻辑上判断？</p>

<p>集合和逻辑，感觉好麻烦。</p>

<pre><code class="language-tla+">
define
    mio ++ vio == mio &lt;=&gt; vio
    mio -- vio == ~mio &lt;=&gt; vio
end define;
</code></pre>

<p>这样很省事，但是我需要的是集合运算。</p>

<pre><code class="language-tla+">   \* symbol define
   DMM(Mio, Vio) == IF Mio.fao = Vio.fao THEN TRUE ELSE FALSE 
   M ++ V == /\ DMM(M, V)
             /\ IFFP([mio |-&gt; M.rio, vio |-&gt; V.rio, ilio |-&gt; M.fao])
   M -- V == /\ DMM(M, V)
             /\ IFCP([mio |-&gt; M.rio, vio |-&gt; V.rio, ilio |-&gt; M.fao])
             
   RIFO == [](a ++ b)
</code></pre>

<h3 id="q2tla的逻辑操作符">Q2：TLA+的逻辑操作符</h3>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">\A</code> 全部</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">\E</code> 存在</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">=&gt;</code> 逻辑判断，蕴含</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">&lt;=&gt;</code> 逻辑判断，与或</p>
  </li>
</ul>

<h3 id="q3tla的表达式有哪些">Q3：TLA+的表达式有哪些？</h3>

<p><strong>LET IN</strong></p>

<pre><code class="language-tla+">RotateRight(seq) ==
  LET
    last == seq[Len(seq)]
    first == SubSeq(seq, 1, Len(seq) - 1)
  IN &lt;&lt;last&gt;&gt; \o first
&gt;&gt; RotateRight(&lt;&lt;1, 2, 3&gt;&gt;)
&lt;&lt;3, 1, 2&gt;&gt;
</code></pre>

<p><strong>IF THEN ELSE</strong></p>

<p><code class="language-plaintext highlighter-rouge">IF Condition THEN Exp1 ELSE Exp2</code></p>

<p><strong>CHOOSE</strong></p>

<p>A case statement. Subsequent cases are marked by a <code class="language-plaintext highlighter-rouge">[]</code>.</p>

<pre><code class="language-tla+">CASE x = 1 -&gt; TRUE
  [] x = 2 -&gt; TRUE
  [] x = 3 -&gt; 7
  [] OTHER -&gt; FALSE
</code></pre>

<p>CHOOSE x \in S : P(x) is “select an x such that P(x) is true.”</p>

<h2 id="tla-的函数">TLA+ 的函数</h2>

<h3 id="q1domain函数的域">Q1：DOMAIN——函数的域</h3>

<p>DOMAIN，给予一个函数可能的输入</p>

<blockquote>
  <p>If <code class="language-plaintext highlighter-rouge">func == [x \in set |-&gt; ...]</code> , then <code class="language-plaintext highlighter-rouge">DOMAIN func = set</code>.</p>
</blockquote>

<p>测试一下吧。</p>

<p><del>在tla+中函数输入一般用 <code class="language-plaintext highlighter-rouge">[]</code> 方括号括起来。那么圆括号 <code class="language-plaintext highlighter-rouge">()</code> 表示什么呢？</del></p>

<p>在规范中定义函数 foo。</p>

<pre><code class="language-tla+">\* in define
foo(S) == [x \in S |-&gt; x + 1]
</code></pre>

<p>然后在检查中测试：</p>

<p><code class="language-plaintext highlighter-rouge">foo(1..3)</code> =&gt; <code class="language-plaintext highlighter-rouge">&lt;&lt;2, 3, 4&gt;&gt;</code></p>

<p>如果在foo前加上 <code class="language-plaintext highlighter-rouge">DOMAIN</code> 呢？</p>

<p><code class="language-plaintext highlighter-rouge">DOMAIN {1, 2, 3}</code> =&gt; <code class="language-plaintext highlighter-rouge">{1, 2, 3}</code></p>

<p>另外有一个问题：</p>

<blockquote>
  <p>为什么以下形式在tla+中是非法表达？</p>
  <blockquote>
    <p><code class="language-plaintext highlighter-rouge">foo[1..3]</code></p>
  </blockquote>
</blockquote>

<p>我想是因为我的定义是：<code class="language-plaintext highlighter-rouge">foo(S) == [x \in S |-&gt; x + 1]</code></p>

<p>如果修改为：<code class="language-plaintext highlighter-rouge">foo[x \in 1..3] == "ok"</code></p>

<p>进行测试：<code class="language-plaintext highlighter-rouge">foo[1]</code> =&gt; <code class="language-plaintext highlighter-rouge">"ok"</code>，<code class="language-plaintext highlighter-rouge">DOMAIN foo</code> =&gt; <code class="language-plaintext highlighter-rouge">{1, 2, 3}</code></p>

<p>是可以通过的。</p>

<blockquote>
  <p>那么可以把 <code class="language-plaintext highlighter-rouge">foo[x \in 1..3]</code> 替换成 <code class="language-plaintext highlighter-rouge">foo(x \in 1..3)</code> 吗？</p>
</blockquote>

<p>不能，定义<code class="language-plaintext highlighter-rouge">foo(x \in 1..3) == "ok"</code> 会出错。</p>

<blockquote>
  <p>很显然圆括号的定义不是函数定义，那么圆括号定义了什么呢？</p>
</blockquote>

<p>——<strong>操作符</strong></p>

<blockquote>
  <p>那么函数可以缺少域的定义吗？</p>
</blockquote>

<p>不能，定义 <code class="language-plaintext highlighter-rouge">foo[x] == "ok"</code> 会出错：</p>

<h3 id="q2函数的分支">Q2：@@——函数的分支</h3>

<p>需要导入 TLC 扩展。</p>

<p><code class="language-plaintext highlighter-rouge">f @@ g</code> 相当于 <code class="language-plaintext highlighter-rouge">Merge(f, g)</code>，功能是测试域的所有情况。</p>

<p>首先是在函数 <code class="language-plaintext highlighter-rouge">f</code> 的域中的元素，根据函数 <code class="language-plaintext highlighter-rouge">f</code> 的映射规则得到值域。</p>

<p>其次是在函数 <code class="language-plaintext highlighter-rouge">g</code> 的域中的元素，根据函数 <code class="language-plaintext highlighter-rouge">g</code> 的映射规则得到值域。</p>

<blockquote>
  <p>那如果函数f 和函数 g 的值域重合了怎么办？</p>
</blockquote>

<p>其中，<code class="language-plaintext highlighter-rouge">Merge</code> 的定义如下：</p>

<pre><code class="language-tla+">Merge(f, g) == [
  x \in (DOMAIN f) \union (DOMAIN g) |-&gt;
    IF x \in DOMAIN f THEN f[x] ELSE g[x]
  ]
</code></pre>

<p>很显然，函数<code class="language-plaintext highlighter-rouge">f</code>的判断是更加优先的。一个元素首先会在 <code class="language-plaintext highlighter-rouge">f</code> 的域中进行判断，然后才是 <code class="language-plaintext highlighter-rouge">g</code> 。</p>

<p>测试：</p>

<pre><code class="language-tla+">f[x \in 1..5] == "m"
g[x \in 2..9] == "k"
f @@ g
</code></pre>

<p>=&gt; <code class="language-plaintext highlighter-rouge">&lt;&lt;"m", "m", "m", "m", "m", "k", "k", "k", "k"&gt;&gt;</code></p>

<p>可以看到，函数 <code class="language-plaintext highlighter-rouge">f</code> 和函数 <code class="language-plaintext highlighter-rouge">g</code> 存在域的交集 <code class="language-plaintext highlighter-rouge">2..5</code> ，此时域中元素依据 <code class="language-plaintext highlighter-rouge">f</code> 的规则映射到值域中。</p>
<h3 id="q3无名函数">Q3：:&gt;——无名函数</h3>

<pre><code class="language-tla+">&gt;&gt; (2 :&gt; 3)[2]
3
&gt;&gt; ("a" :&gt; "b").a
"b"
</code></pre>

<p>看起来像极了 lambda：</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="q4函数的集合">Q4：函数的集合</h3>

<p><code class="language-plaintext highlighter-rouge">|-&gt;</code> 用于函数/结构体内的映射，<code class="language-plaintext highlighter-rouge">-&gt;</code> 用于函数集的映射，看起来会产生笛卡尔积。</p>

<pre><code class="language-tla+">&gt;&gt; [s \in {"a", "b"} |-&gt; {1, 2}]
[a |-&gt; {1, 2}, b |-&gt; {1, 2}]
&gt;&gt; [{"a", "b"} -&gt; {1, 2}]
{ [a |-&gt; 1, b |-&gt; 1],
     [a |-&gt; 1, b |-&gt; 2],
     [a |-&gt; 2, b |-&gt; 1],
     [a |-&gt; 2, b |-&gt; 2] }
</code></pre>

<p>暂时不知道应该怎么用。</p>

<p>测试一下吧：</p>

<pre><code class="language-tla+">[{"siv", "kiv", "kig"} -&gt; {"m", "o", "k"}]
</code></pre>

<p>=&gt;</p>

<pre><code class="language-tla+">{ [siv |-&gt; "m", kiv |-&gt; "m", kig |-&gt; "m"],
     [siv |-&gt; "m", kiv |-&gt; "m", kig |-&gt; "o"],
     [siv |-&gt; "m", kiv |-&gt; "m", kig |-&gt; "k"],
     [siv |-&gt; "m", kiv |-&gt; "o", kig |-&gt; "m"],
     [siv |-&gt; "m", kiv |-&gt; "o", kig |-&gt; "o"],
     [siv |-&gt; "m", kiv |-&gt; "o", kig |-&gt; "k"],
     [siv |-&gt; "m", kiv |-&gt; "k", kig |-&gt; "m"],
     [siv |-&gt; "m", kiv |-&gt; "k", kig |-&gt; "o"],
     [siv |-&gt; "m", kiv |-&gt; "k", kig |-&gt; "k"],
     [siv |-&gt; "o", kiv |-&gt; "m", kig |-&gt; "m"],
     [siv |-&gt; "o", kiv |-&gt; "m", kig |-&gt; "o"],
     [siv |-&gt; "o", kiv |-&gt; "m", kig |-&gt; "k"],
     [siv |-&gt; "o", kiv |-&gt; "o", kig |-&gt; "m"],
     [siv |-&gt; "o", kiv |-&gt; "o", kig |-&gt; "o"],
     [siv |-&gt; "o", kiv |-&gt; "o", kig |-&gt; "k"],
     [siv |-&gt; "o", kiv |-&gt; "k", kig |-&gt; "m"],
     [siv |-&gt; "o", kiv |-&gt; "k", kig |-&gt; "o"],
     [siv |-&gt; "o", kiv |-&gt; "k", kig |-&gt; "k"],
     [siv |-&gt; "k", kiv |-&gt; "m", kig |-&gt; "m"],
     [siv |-&gt; "k", kiv |-&gt; "m", kig |-&gt; "o"],
     [siv |-&gt; "k", kiv |-&gt; "m", kig |-&gt; "k"],
     [siv |-&gt; "k", kiv |-&gt; "o", kig |-&gt; "m"],
     [siv |-&gt; "k", kiv |-&gt; "o", kig |-&gt; "o"],
     [siv |-&gt; "k", kiv |-&gt; "o", kig |-&gt; "k"],
     [siv |-&gt; "k", kiv |-&gt; "k", kig |-&gt; "m"],
     [siv |-&gt; "k", kiv |-&gt; "k", kig |-&gt; "o"],
     [siv |-&gt; "k", kiv |-&gt; "k", kig |-&gt; "k"] }
</code></pre>

<p>看起来真的很方便，直接帮助我罗列了所有可能。</p>

<h2 id="总结">总结</h2>

<p>在本篇笔记中，我记录了自己了解 TLA+ 基本操作符，表达式和函数的过程。</p>

<p>自定义操作符虽然很有意思，不过在基础学习的阶段，还是了解好 <code class="language-plaintext highlighter-rouge">\A</code> <code class="language-plaintext highlighter-rouge">\E</code> <code class="language-plaintext highlighter-rouge">f[x \in set]</code> 这些基础定义的特性要好一点。</p>]]></content><author><name>甲与</name></author><category term="TLAplus" /><summary type="html"><![CDATA[了解一下 tlaplus 的操作符和函数。]]></summary></entry><entry><title type="html">Tlaplus：电报问题</title><link href="/tlaplus-%E7%94%B5%E6%8A%A5%E9%97%AE%E9%A2%98/" rel="alternate" type="text/html" title="Tlaplus：电报问题" /><published>2024-03-14T00:00:00+08:00</published><updated>2024-03-14T00:00:00+08:00</updated><id>/tlaplus%EF%BC%9A%E7%94%B5%E6%8A%A5%E9%97%AE%E9%A2%98</id><content type="html" xml:base="/tlaplus-%E7%94%B5%E6%8A%A5%E9%97%AE%E9%A2%98/"><![CDATA[<p>在一个小编程中测试tlaplus。</p>

<h2 id="电报问题描述">电报问题描述</h2>

<p>现在请你设计一个电报交换系统，包括以下几个条件：</p>

<ul>
  <li>每一个电报只能在银行中两个不同的人间进行传递，而且每个电报至少一美元。</li>
  <li>如果电报是成功的，那么电报的值便会从发送者方减去，而加在接收方的账户中。</li>
  <li>如果电报失败，两个账户将没有任何改变。</li>
  <li>电报不能让任何一个账户是负值。</li>
  <li>多个电报可能同时发生。</li>
</ul>

<h2 id="单进程建模">单进程建模</h2>

<h3 id="单进程代码">单进程代码</h3>

<pre><code class="language-PlusCal">EXTENDS Integers

(*--algorithm wire
variables
    people = {"Zhang", "Wang"},
    acc = [p \in people |-&gt; 5],
    sender = "Zhang",
    reciver = "Wang",
    amount \in 1..4;
        
define
        NoOverdrafts == \A p \in people: acc[p] &gt;= 0
end define;

begin
    Withdraw:
        acc[sender] := acc[sender] - amount;
    Deposite:
        acc[reciver] := acc[reciver] + amount;
end algorithm;**)
</code></pre>

<h3 id="报错情况设置">报错情况设置</h3>

<p>其中，如果修改 amount 的值为 范围 1..6，则会报错。</p>

<p>因为小张和小王的初始金额都是5，如果一次电报发送6美元，无论谁发都会出现负值。</p>

<p>不过有意思的是错误数量。</p>

<p>分别试试把 <code class="language-plaintext highlighter-rouge">amount</code> 设为 1..7，1..9看看吧。</p>

<p>可以看到的是，错误检测始终只报出一个错误，似乎是检测到错误就停止了。但是可区分的状态却有所不同。</p>

<ul>
  <li>Diameter，States Found，Distinct State，Queue Size分别是什么？有什么方法可以在无错状态下查看执行路径？</li>
</ul>

<h2 id="多进程处理">多进程处理</h2>

<h3 id="多进程代码">多进程代码</h3>

<pre><code class="language-PlusCal">EXTENDS Integers

(*--algorithm wire
variables
    people = {"Zhang", "Wang"},
    acc = [p \in people |-&gt; 5];
        
define
        NoOverdrafts == \A p \in people: acc[p] &gt;= 0
end define;

process Wire \in 1..2
    variables
        sender = "Zhang",
        reciver = "Wang",
        amount \in 1..acc[sender];

begin
    CheckFonds:
        if amount &lt;= acc[sender] then
            Withdraw:
                acc[sender] := acc[sender] - amount;
            Deposit:
                acc[reciver] := acc[reciver] + amount;
        end if;
end process;

end algorithm;**)

</code></pre>

<h3 id="error-trace">Error Trace</h3>

<p>执行上述代码，我们来看看 Error Trace 是什么样的吧。</p>

<p>看完这些，你会发现，pc代表机器所处的状态。</p>

<p>里面的两个值分别代表两个机器本身处于什么状态。</p>

<p>那么这整个堆栈显示了什么错误呢？</p>

<p>我们可以看到 amount 的值为<code class="language-plaintext highlighter-rouge">&lt;1, 5&gt;</code>，这意味着在该情形下，第一个进程要发1美元，第二个进程要发5美元过去。</p>

<p>而错误发生在第四步到第五步之间。发生了什么呢？</p>

<p>小张想给小王寄5美元钱，但是只有4美元，减去后发现账户余额变成负一美元。这种错误超过了<code class="language-plaintext highlighter-rouge">acc[p]&gt;0</code> 的约束条件。</p>

<p>而这五个步骤中整体发生了什么呢？</p>

<p>小张想给小王寄钱，在小王还没有收到钱时，小张第一次寄一美元，第二次寄五美元，账户变成负值。</p>

<h3 id="把-check-和-withdraw-放在一起">把 Check 和 Withdraw 放在一起</h3>

<p>那我们要怎样规避这些错误呢？</p>

<p>来看看教材给出的方案吧。</p>

<p>它把检查和账户减发送金额的步骤合在了一起。这样，当小张发送一美元完成检查时，由于金额一并被减去了，所以进程二检查时发送的金额不会再超过现有金额四美元。</p>

<pre><code class="language-tla+">EXTENDS Integers

(*--algorithm wire
variables
    people = {"Zhang", "Wang"},
    acc = [p \in people |-&gt; 5];
        
define
        NoOverdrafts == \A p \in people: acc[p] &gt;= 0
end define;

process Wire \in 1..2
    variables
        sender = "Zhang",
        reciver = "Wang",
        amount \in 1..acc[sender];

begin
    CheckAndWithDraw:
        if amount &lt;= acc[sender] then
                acc[sender] := acc[sender] - amount;
            Deposit:
                acc[reciver] := acc[reciver] + amount;
        end if;
end process;

end algorithm;**)


\* BEGIN TRANSLATION
</code></pre>

<p>现在没有问题了。</p>

<h2 id="temporal-properties-时间属性">Temporal Properties 时间属性</h2>

<p>之后要做什么？</p>

<p>整体金额不变的部分称为 <code class="language-plaintext highlighter-rouge">Temporal Properties</code> ，世俗的属性，时间的属性。而每次金额不变的属性称为 <code class="language-plaintext highlighter-rouge">invariants</code> ，也就是不变量。两者最大的区别目前看来是是否需要跨越不同的系统状态进行检查。 <code class="language-plaintext highlighter-rouge">invariants</code> 只需要在状态内检查属性就可以了。不过 <code class="language-plaintext highlighter-rouge">Temporal Properties</code> 则需要综合不同的系统状态考虑约束条件。</p>

<p>语法格式变得奇怪了。</p>

<p><code class="language-plaintext highlighter-rouge">EventuallyConsistent</code> ，最终不变的。</p>

<ul>
  <li>问题是在 <code class="language-plaintext highlighter-rouge">PlusCal</code> 中，<code class="language-plaintext highlighter-rouge">&lt;&gt;[]()</code> 是什么表达？</li>
</ul>

<p>来看看DuckDuckgo上有什么答案吧。</p>

<p>首先来解释 <code class="language-plaintext highlighter-rouge">&lt;&gt;[]P</code> 这个表达的含义吧。</p>

<p>根据<a href="https://www.learntla.com/core/temporal-logic.html">TLC手册</a>的表达，</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">语法</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[]P</code></td>
      <td>P总为真</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">&lt;&gt;P</code></td>
      <td>P最终为真</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[]~P</code></td>
      <td>P总为假</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">~[]P</code></td>
      <td>P不总为真，有假的情况</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">&lt;&gt;[]P</code></td>
      <td>最终P总为真（中间状态可以为假，但首尾状态应为真）</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[]&lt;&gt;P</code></td>
      <td>P总最终为真</td>
    </tr>
  </tbody>
</table>

<p>看起来真是相当复杂的表述。</p>

<p>那么这种可能性中发生了什么呢？</p>

<p><img src="/assets/post_images/image-20240415192831616.png" alt="" /></p>

<ul>
  <li>恩……为什么小王没有收到最后一元呢？</li>
</ul>

<p>系统进行到第五步的时候出错了。</p>

<p>大概意思可能是，在状态4，进程2停止时，按照 <code class="language-plaintext highlighter-rouge">EventuallyConsistent</code> 的声明，系统总金额应该“最终”等于10。不过由于另一个进程的1元还没有送到，所以系统状态违反了时间属性的约束，就报错了。</p>

<ul>
  <li>那有什么处理方法吗？</li>
</ul>

<p>作者说，可以放松 <code class="language-plaintext highlighter-rouge">NoOverdrafts</code>或 <code class="language-plaintext highlighter-rouge">EventuallyConsistent</code>  条件，尝试不同的执行，告诉TLCplus在 <code class="language-plaintext highlighter-rouge">withdraw</code> 和 <code class="language-plaintext highlighter-rouge">deposit</code> 之间不能 <code class="language-plaintext highlighter-rouge">stutter</code>，或者干脆把 <code class="language-plaintext highlighter-rouge">check</code>，<code class="language-plaintext highlighter-rouge">withdraw</code> 和 <code class="language-plaintext highlighter-rouge">deposit</code> 三个步骤组成一个原子。</p>

<h2 id="参考书籍">参考书籍</h2>

<ul>
  <li>Pratical TLA+, by Hilllel Wayne</li>
</ul>]]></content><author><name>甲与</name></author><category term="形式化验证" /><summary type="html"><![CDATA[在一个小编程中测试tlaplus。]]></summary></entry><entry><title type="html">Tlaplus pluscal</title><link href="/tlaplus-Pluscal/" rel="alternate" type="text/html" title="Tlaplus pluscal" /><published>2024-03-13T00:00:00+08:00</published><updated>2024-03-13T00:00:00+08:00</updated><id>/tlaplus%20Pluscal</id><content type="html" xml:base="/tlaplus-Pluscal/"><![CDATA[<p>探索一下 tlaplus pluscal 的基本功能。</p>

<h2 id="q1pluscal代码的基本格式是怎样的">Q1：Pluscal代码的基本格式是怎样的？</h2>

<p>一个标准的Pluscal代码由以下几部分组成。</p>

<pre><code class="language-tla+">---- (1) MODULE wire ----
EXTENDS Integers \* (2)
(*--algorithm wire \* (3)
    variables (4)
        people = {"alice", "bob"},
        acc = [alice |-&gt; 5, bob |-&gt; 5];
begin \* (5)
    skip;
end algorithm;*) (3)
==== \* (1)
</code></pre>

<p>可以看到，一个标准的 Pluscal 代码由上述五部分组成。</p>

<h3 id="1首尾标识和模型名">（1）首尾标识和模型名</h3>

<pre><code class="language-tla+">---- MODULE name ----
contents of pluscal
====
</code></pre>

<h3 id="2导入的包名">（2）导入的包名</h3>

<pre><code class="language-tla+">EXTENDS Package-names
</code></pre>

<p>常用的包有：Integers, …</p>

<h3 id="3算法的起止声明用注释声明形式">（3）算法的起止声明，用注释+声明形式</h3>
<pre><code class="language-tla+">(*--algorithm name
...
end algorithm;*)
</code></pre>

<h3 id="4变量声明">（4）变量声明</h3>
<pre><code class="language-tla+">variables
	var_1 = value_1,
	var_2 = value_2,
	...
	var_n = value_n;
</code></pre>

<h3 id="5算法声明">（5）算法声明</h3>

<pre><code class="language-tla+">begin
	...;
</code></pre>

<h2 id="q2能不能在tla中测试语句">Q2：能不能在TLA+中测试语句？</h2>

<p>tla+中的表达要么是 <strong>值</strong>（value），要么是 <strong>操作符</strong>（operator）。</p>

<p>在 <code class="language-plaintext highlighter-rouge">Module Checking Results</code> 栏目下可以看到 <code class="language-plaintext highlighter-rouge">Evaluate Constant Expression</code> 选项。在Expression 文本框中输入 tla+ 表达式，按 <code class="language-plaintext highlighter-rouge">F11</code> 即可在 Value 窗口查看语句执行结果。</p>

<h2 id="q3tla-的基本操作符operators有哪些">Q3：tla+ 的基本操作符（operators）有哪些？</h2>

<h3 id="1基础操作符">（1）基础操作符</h3>

<p>直接看表好了：</p>

<table>
  <thead>
    <tr>
      <th>表达式</th>
      <th>意义</th>
      <th>例子</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">x = y</code></td>
      <td>等于（Equal）</td>
      <td><code class="language-plaintext highlighter-rouge">1 = 3</code> =&gt; <code class="language-plaintext highlighter-rouge">FALSE</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">x /= y</code></td>
      <td>不等于（Not Equal）</td>
      <td><code class="language-plaintext highlighter-rouge">1 /= 3</code> =&gt; <code class="language-plaintext highlighter-rouge">TRUE</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">x # y</code></td>
      <td>不等于（Not Equal）</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">x /\ y</code></td>
      <td>且（and）</td>
      <td><code class="language-plaintext highlighter-rouge">TRUE /\ FALSE</code> =&gt; <code class="language-plaintext highlighter-rouge">FALSE</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">x \/ y</code></td>
      <td>或（or）</td>
      <td><code class="language-plaintext highlighter-rouge">TRUE \/ FALSE</code> =&gt; <code class="language-plaintext highlighter-rouge">TRUE</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">x := y</code></td>
      <td>设置（Assignment）</td>
      <td>only in pluscal</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">=</code> 和 <code class="language-plaintext highlighter-rouge">:=</code> 的区别是什么？</p>
</blockquote>

<p>在Pluscal 中，<code class="language-plaintext highlighter-rouge">x = y</code> 如果不是第一次声明x，意味着相等判断。如果是第一次声明x，则意味着初始化x的值。<code class="language-plaintext highlighter-rouge">x := y</code> 则意味着重新给 x 设定值。</p>

<p>而在tla+中，<code class="language-plaintext highlighter-rouge">x = y</code> 的功能和Pluscal相同。但是重新赋值选项则以 <code class="language-plaintext highlighter-rouge">x' = new_vlue</code> 方式进行。</p>

<h3 id="2集合">（2）集合</h3>

<p>除了整数（Integers）之外，tla+还包括集合（set）、元组（tuples/sequences）、结构体（structures）和函数（functions）。</p>

<blockquote>
  <p><strong>集合</strong>的所有的元素都必须有相同的类型。
例如 <code class="language-plaintext highlighter-rouge">A = {1, 2, 3}</code> 是合法的，因为所有元素都是整数。
但是 <code class="language-plaintext highlighter-rouge">A = {1, 2, "3"}</code> 则是非法的，因为集合 A 中同时包含了整数和字符串两种数据类型。</p>
</blockquote>

<h4 id="集合操作符">集合操作符</h4>

<p>那么在tla+中集合的基本操作符有那些呢？</p>

<p>来看看表格吧：</p>

<table>
  <thead>
    <tr>
      <th>表达式</th>
      <th>意义</th>
      <th>例子</th>
      <th>备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">x \in set</code></td>
      <td>x 是集合set的元素</td>
      <td><code class="language-plaintext highlighter-rouge">1 \in 1..3</code> =&gt; <code class="language-plaintext highlighter-rouge">TRUE</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">x \notin set</code></td>
      <td>x不是集合set的元素</td>
      <td><code class="language-plaintext highlighter-rouge">1 \notin 1..3</code> =&gt; <code class="language-plaintext highlighter-rouge">FALSE</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">set1 \subsetq set2</code></td>
      <td>set1是集合set2的子集</td>
      <td><code class="language-plaintext highlighter-rouge">{1, 3} \subsetq 1..3</code> =&gt; <code class="language-plaintext highlighter-rouge">TRUE</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">set1 \union set2</code></td>
      <td>求set1和set2的并集</td>
      <td><code class="language-plaintext highlighter-rouge">{1, 3} \union {2}</code> =&gt; <code class="language-plaintext highlighter-rouge">{1, 2, 3}</code></td>
      <td>其它表达：<code class="language-plaintext highlighter-rouge">\cup</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">set1 \intersect set2</code></td>
      <td>求set1和set2的交集</td>
      <td><code class="language-plaintext highlighter-rouge">{1, 3} \intersect {1, 4}</code> =&gt; <code class="language-plaintext highlighter-rouge">{1}</code></td>
      <td>其它表达：<code class="language-plaintext highlighter-rouge">\cap</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">set1 \ set2</code></td>
      <td>求set1和set2的差集</td>
      <td><code class="language-plaintext highlighter-rouge">{1, 3} \ {3}</code> =&gt; <code class="language-plaintext highlighter-rouge">{1}</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Cardinality(set)</code></td>
      <td>求set的长度</td>
      <td><code class="language-plaintext highlighter-rouge">Cardinality({1..8)</code> =&gt; 8</td>
      <td>需要导入包 <code class="language-plaintext highlighter-rouge">FiniteSets</code></td>
    </tr>
  </tbody>
</table>

<p>还有两种集合的遍历和映射表达方式。</p>

<h4 id="集合过滤filter方式">集合过滤（filter）方式</h4>

<p>集合过滤的基本表达方式为：<code class="language-plaintext highlighter-rouge">{x \in set: conditional}</code> ，意义是根据条件筛选集合中的元素。</p>

<p>比如说：</p>

<p><code class="language-plaintext highlighter-rouge">{x \in 1..8: x + 2 &gt; 3}</code> =&gt; <code class="language-plaintext highlighter-rouge">{2, 3, 4, 5, 6, 7, 8}</code></p>

<blockquote>
  <p>[!faq] 不过为什么 <code class="language-plaintext highlighter-rouge">1..8</code> 加上括号就会非法呢？</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">{x \in {1..8}: x + 2 &gt; 3}</code> =&gt; wrong</p>

<blockquote>
  <p>[!bug] The `Evaluate Constant Expression� section�s evaluation failed.</p>

  <p>Attempted to apply the operator overridden by the Java method
public static tlc2.value.IntValue
tlc2.module.Integers.Plus(tlc2.value.IntValue,tlc2.value.IntValue), but it produced the following error:
argument type mismatch</p>
</blockquote>

<p>类型不匹配……java写的。</p>

<p>如果在外面赋值的时候呢？</p>

<p><code class="language-plaintext highlighter-rouge">1 \in {1..3}</code> 不会返回 <code class="language-plaintext highlighter-rouge">TRUE</code> 。</p>

<p>换言之 <code class="language-plaintext highlighter-rouge">1..3</code> 本身就是一个集合。</p>

<p>验证一下吧：</p>

<p><code class="language-plaintext highlighter-rouge">Cardinality({1..3})</code> =&gt; 1</p>

<p><code class="language-plaintext highlighter-rouge">Cardinality(1..3)</code> =&gt; 3</p>

<p>果然如此。</p>

<p>所以实际上 <code class="language-plaintext highlighter-rouge">{x \in {1..8}: ...}</code> 中 x的遍历实际上会遍历到 <code class="language-plaintext highlighter-rouge">{1, 2, 3, 4, 5, 6, 7, 8}</code> 这个集合本身。</p>

<p>而在后面的 <code class="language-plaintext highlighter-rouge">x + 2 &gt; 3</code> 这个判断中， <code class="language-plaintext highlighter-rouge">&gt;</code> 需要两个参数为整数，第一个为集合，所以出现类型错误。</p>

<p>好吧。</p>

<h4 id="集合映射map方式">集合映射（map）方式</h4>

<p>集合映射的表达方式是：<code class="language-plaintext highlighter-rouge">{expression: x \in set}</code>，意义是对集合中每个元素进行指定动作的处理。</p>

<p>测试一下：</p>

<p><code class="language-plaintext highlighter-rouge">{x + 1 : x \in 1..3}</code> =&gt; <code class="language-plaintext highlighter-rouge">{4, 5, 6}</code></p>

<h4 id="对比rif和tla的集合操作">对比rif和tla+的集合操作</h4>

<blockquote>
  <p>[!faq] 那么集合过滤与集合映射与rif的区别何在呢？</p>
</blockquote>

<p>之前我曾经编写过rif函数，大概格式是：</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">rlb-rif</span> <span class="o">'</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">'</span><span class="p">()</span>
		 <span class="p">(</span><span class="nv">rlb-fip</span> <span class="p">(</span><span class="nv">r</span> <span class="nv">f</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">r</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>
		 <span class="p">(</span><span class="nv">rlb-ted</span> <span class="p">(</span><span class="nv">r</span> <span class="nv">f</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">r</span><span class="p">))))</span>
<span class="c1">;;=&gt;'(1)</span>
</code></pre></div></div>

<p>tla+中的过滤和映射在我这里则是fip和ted。</p>

<p>不过我还能找到之前的代码吗？</p>

<p>找到了：</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;;动作执行局部函数</span>
  <span class="p">(</span><span class="nb">defvar</span> <span class="nv">rlb-tedo</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">rlb-solimi</span> <span class="nv">rlb-ted</span> <span class="p">(</span><span class="nv">hisos</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
              <span class="o">`</span><span class="p">(</span><span class="k">progn</span>
                 <span class="p">(</span><span class="nb">setf</span> <span class="nv">rlb-tedo</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">rlb-tedo</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">setf</span> <span class="nv">rlb-rinafo</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">rlb-rinafo</span><span class="p">))</span>
                 <span class="p">(</span><span class="k">lambda</span> <span class="o">,</span><span class="nv">hisos</span> <span class="o">,@</span><span class="nv">body</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">rlb-solimi</span> <span class="err">态势</span> <span class="p">(</span><span class="nv">hisos</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
            <span class="o">`</span><span class="p">(</span><span class="nv">rlb-ted</span> <span class="o">,</span><span class="nv">hisos</span> <span class="o">,@</span><span class="nv">body</span><span class="p">))</span>

<span class="c1">;;条件判断局部函数</span>
  <span class="p">(</span><span class="nb">defvar</span> <span class="nv">rlb-fipo</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">rlb-solimi</span> <span class="nv">rlb-fip</span> <span class="p">(</span><span class="nv">hisos</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
              <span class="o">`</span><span class="p">(</span><span class="k">progn</span>
                 <span class="p">(</span><span class="nb">setf</span> <span class="nv">rlb-fcipo</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">rlb-fipo</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">setf</span> <span class="nv">rlb-rinafo</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">rlb-rinafo</span><span class="p">))</span>
                 <span class="p">(</span><span class="k">lambda</span> <span class="o">,</span><span class="nv">hisos</span> <span class="o">,@</span><span class="nv">body</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">rlb-solimi</span> <span class="err">情境</span> <span class="p">(</span><span class="nv">hisos</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
            <span class="o">`</span><span class="p">(</span><span class="nv">rlb-fip</span> <span class="o">,</span><span class="nv">hisos</span> <span class="o">,@</span><span class="nv">body</span><span class="p">))</span>

<span class="c1">;;自此而彼按照指定条件和动作处理列表</span>
  <span class="p">(</span><span class="nb">defvar</span> <span class="nv">rlb-rifo</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">defun</span> <span class="nv">rlb-rifa_loyo</span> <span class="p">(</span><span class="nv">rino</span> <span class="nv">famo</span> <span class="nv">fipo</span> <span class="nv">tedo</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">equal</span> <span class="no">nil</span> <span class="p">(</span><span class="nb">equal</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">rino</span><span class="p">)</span> <span class="no">nil</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">rlb-rif</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">rino</span><span class="p">)</span>
                 <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fipo</span> <span class="nv">rino</span> <span class="nv">famo</span><span class="p">)</span>
                     <span class="p">(</span><span class="nb">append</span>
                      <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">tedo</span> <span class="nv">rino</span> <span class="nv">famo</span><span class="p">))</span> <span class="nv">famo</span><span class="p">)</span>
                     <span class="nv">famo</span><span class="p">)</span>
                 <span class="nv">fipo</span> <span class="nv">tedo</span><span class="p">)</span>
        <span class="p">(</span><span class="k">progn</span>
          <span class="p">(</span><span class="nb">setf</span> <span class="nv">rlb-rifo</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">rlb-rifo</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">setf</span> <span class="nv">rlb-rinafo</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">rlb-rinafo</span><span class="p">))</span>
          <span class="nv">famo</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">rlb-solimi</span> <span class="nv">rlb-rif</span> <span class="p">(</span><span class="nv">rino</span> <span class="nv">famo</span> <span class="nv">fipo</span> <span class="nv">tedo</span><span class="p">)</span>
    <span class="o">`</span><span class="p">(</span><span class="nv">rlb-rifa_loyo</span> <span class="o">,</span><span class="nv">rino</span> <span class="o">,</span><span class="nv">famo</span> <span class="o">,</span><span class="nv">fipo</span> <span class="o">,</span><span class="nv">tedo</span><span class="p">))</span>

<span class="p">(</span><span class="nv">rlb-solimi</span> <span class="err">迈进</span> <span class="p">(</span><span class="nv">rino</span> <span class="nv">famo</span> <span class="nv">fipo</span> <span class="nv">tedo</span><span class="p">)</span>
            <span class="o">`</span><span class="p">(</span><span class="nv">rlb-rif</span> <span class="o">,</span><span class="nv">rino</span> <span class="o">,</span><span class="nv">famo</span> <span class="o">,</span><span class="nv">fipo</span> <span class="o">,</span><span class="nv">tedo</span><span class="p">))</span>

</code></pre></div></div>

<p>那么tla+能不能把遍历和过滤结合在一起呢？</p>

<p><code class="language-plaintext highlighter-rouge">{e + 3 : e \in {e \in 1..9 : e &gt; 3}}</code> =&gt; <code class="language-plaintext highlighter-rouge">{7, 8, 9, 10, 11, 12}</code></p>

<p>同样的功能，在rlisp中则要表达为：</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">rlb-rif</span> <span class="o">'</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">'</span><span class="p">()</span>
		 <span class="p">(</span><span class="nv">rlb-fip</span> <span class="p">(</span><span class="nv">r</span> <span class="nv">f</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">r</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
		 <span class="p">(</span><span class="nv">rlb-ted</span> <span class="p">(</span><span class="nv">r</span> <span class="nv">f</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">r</span><span class="p">)</span> <span class="mi">3</span><span class="p">)))</span>
<span class="c1">;;=&gt;'(7, 8, 9, 10, 11, 12)</span>
</code></pre></div></div>

<p>不过最大的区别也许在于，tla+中集合要求所有元素都是相同的类型。但是，rlisp中的元素则是任意的。</p>

<h3 id="3元组">（3）元组</h3>

<h4 id="元组表达式">元组表达式</h4>

<p>tla+中的元组表达形式为：<code class="language-plaintext highlighter-rouge">&lt;&lt;element_1, element_2, ...&gt;&gt;</code>。</p>

<p>和集合不同，tla+的元组不需要所有元素都为相同的类型。</p>

<p>可以通过 <code class="language-plaintext highlighter-rouge">元组名[位置]</code> 的方式来访问元组中的元素。例如：</p>

<p>先进行简单测试来看看吧。</p>

<p><code class="language-plaintext highlighter-rouge">&lt;&lt;1, 2, 1..3&gt;&gt;[3]</code> =&gt; <code class="language-plaintext highlighter-rouge">1..3</code>
<code class="language-plaintext highlighter-rouge">&lt;&lt;1, {1, 3}, 2&gt;&gt;[2]</code> =&gt; <code class="language-plaintext highlighter-rouge">{1, 3}</code></p>

<p>然后在模型中测试：</p>

<pre><code class="language-tla+">
(*--algorithm t2
    variables
        a = &lt;&lt;1, 2, {1, 4}&gt;&gt;;
        
define
    Famo == &lt;&gt;(a = {1, 4})
end define;

begin
    test:
        a := a[3];
end algorithm;*)   

</code></pre>

<blockquote>
  <p>类型匹配错误！
Attempted to check equality of the function «1, 2, {1, 4}» with the value:
{1, 4}
While working on the initial state:
/\ a = «1, 2, {1, 4}»
/\ pc = “test”</p>
</blockquote>

<p><del>也就是说，在test执行前，a仍为元组时，对于时间属性Famo的检测要求元组和元素通过 <code class="language-plaintext highlighter-rouge">=</code> 相匹配，结果报错。</del> 因为 <code class="language-plaintext highlighter-rouge">&lt;&gt;P</code> 这种表达要求时间属性首尾状态为真，所以a一开始赋值为 <code class="language-plaintext highlighter-rouge">&lt;&lt;1, 2, {1, 4}&gt;&gt;</code> 注定了它的错误。</p>

<p>另一种检测方式：</p>

<pre><code class="language-tla+">(*--algorithm t2
    variables
        a = &lt;&lt;1, 2, 3&gt;&gt;;
        b = 3;
        
define
    Famo == &lt;&gt;(b = 3)
end define;

begin
    p1: b := a[1];
    p2: b := a[2];
    p3: b := a[3];
end algorithm;*) 
</code></pre>

<h4 id="元组操作符">元组操作符</h4>

<p>tla+ 提供了 <code class="language-plaintext highlighter-rouge">Sequences</code> 扩展包，包括以下操作符：</p>

<p>| 操作符              | 意义            | 例子  |
| —————- | ————- | — |
| <code class="language-plaintext highlighter-rouge">Head(sequence)</code> | 获取序列的第一个元素    |     |
| <code class="language-plaintext highlighter-rouge">Tail(sequence)</code> |               |     |
| <code class="language-plaintext highlighter-rouge">Append(seq, x)</code> |               |     |
| <code class="language-plaintext highlighter-rouge">seq1 \o seq2</code>   | 将序列1和序列2结合在一起 |     |
| <code class="language-plaintext highlighter-rouge">Len(seq)</code>       | 获取序列长度        |     |</p>
<h3 id="4结构体structs">（4）结构体（Structs）</h3>

<p>在tla中，结构体的表达方式为：<code class="language-plaintext highlighter-rouge">[key_1 |-&gt; val_1, key_2 |-&gt; val_2, ...]</code></p>

<p>结构体中的元素可以通过 <code class="language-plaintext highlighter-rouge">结构体名称.键名</code> 进行访问。</p>

<p>例如：</p>

<pre><code class="language-tla+">(*--algorithm t2
    variables
        Alice = [name |-&gt; "Alice", age |-&gt; 23];
        See = 0;
        
define
    Famo == &lt;&gt;(Alice.name = "Alice")
end define;

begin
    p1: See := Alice.name;
    p2: See := Alice.age;
    p3: See := Alice.name;
end algorithm;*)  
</code></pre>

<p>测试通过，Alice的名字自始至终是”Alice”。</p>

<h2 id="q3算法主体">Q3：算法主体</h2>

<h3 id="1assignment">（1）assignment</h3>

<p>Pluscal 通过 <code class="language-plaintext highlighter-rouge">x := value</code> 表达来为变量赋新值。</p>

<h3 id="2assert">（2）assert</h3>

<p>使用assert语句需要导入 <code class="language-plaintext highlighter-rouge">TLC</code> 扩展包。</p>

<p>assert可以通过假定某个变量的值来判断系统状态，用于begin之后的部分。例如我认为在p2状态Alice的名字是bob，结果出错：</p>

<pre><code class="language-tla+">
EXTENDS Integers, FiniteSets, TLC

(*--algorithm t2
    variables
        Alice = [name |-&gt; "Alice", age |-&gt; 23];
        See = 0;
        
define
    Famo == &lt;&gt;(Alice.name = "Alice")
end define;

begin
    p1: See := Alice.name;
    p2: See := Alice.age;
    assert Alice.name = "bob";
    p3: See := Alice.name;
end algorithm;*)   
</code></pre>

<p><img src="/img/user/%E5%9B%BE%E7%89%87/Pasted%20image%2020240318154452.png" alt="Pasted image 20240318154452.png" /></p>

<h3 id="3skip">（3）skip</h3>

<p>在函数主体中，skip表示什么都不做。例如：</p>

<pre><code class="language-tla+">
EXTENDS Integers, FiniteSets, TLC

(*--algorithm t2
    variables
        Alice = [name |-&gt; "Alice", age |-&gt; 23];
        
define
    Famo == &lt;&gt;(Alice.name = "Alice")
end define;

begin
    AfterOneYear: Alice.age := Alice.age + 1;
    AfterThreeYear: Alice.age := Alice.age + 3;
    AfterTenYear: Alice.age := Alice.age + 10;
    assert Alice.age = 27;
end algorithm;*)   
</code></pre>

<p><img src="/img/user/%E5%9B%BE%E7%89%87/Pasted%20image%2020240318155412.png" alt="Pasted image 20240318155412.png" /></p>

<p>在经过十年时，Alice的年龄由于+10而成为37，不同于假定。但是如果在经过十年时使用skip的话——却可以通过测试。</p>

<h3 id="4if">（4）if</h3>

<p>基本格式：</p>

<pre><code class="language-tla+">if condition1 then
  body
elsif condition2 then
  body
else
  body
end if;
</code></pre>

<h3 id="5while">（5）while</h3>

<p>基本格式：</p>

<pre><code class="language-tla+">while condition do
  body
end while;
</code></pre>

<h3 id="6macros">（6）macros</h3>

<p>tla+的macro感觉很像函数。需要注意的是，macro的定义在define之后。</p>

<pre><code class="language-tla+">macro name(arg1, arg2) begin
  \* assignments
end macro;
begin
  name(x, y);
end algorithm;
</code></pre>

<p>那么可不可以通过 macro 来定义fovis呢？</p>

<p>先定义 IMMP（IsMiaMoviaPimo，此集处在维系位图中）吧：</p>

<pre><code class="language-tla+">(*--algorithm t2
    variables
        Moko = [mio |-&gt; {1, 2, 3, 8}, vio |-&gt; {1, 2}, ilio |-&gt; {1, 2, 3, 4, 8}];
        Judgement = FALSE

define
    Famo == &lt;&gt;(Judgement = FALSE)
end define;

macro IMMP(Moko) begin
    Judgement := \A m \in Moko.mio : m \in Moko.ilio
end macro;

begin
P1: IMMP(Moko);
end algorithm;*)  
</code></pre>

<p><code class="language-plaintext highlighter-rouge">Moko.mio</code>中的元素都在 <code class="language-plaintext highlighter-rouge">Moko.ilio</code> 中，IMMP应为假，测试通过。接下来换几组数据试试看吧。</p>

<p>| Moko.mio       | Moko.ilio      | Judgement | 解释          |
| ————– | ————– | ——— | ———– |
| <code class="language-plaintext highlighter-rouge">{1, 2, 3, 8}</code> | <code class="language-plaintext highlighter-rouge">{1, 2, 3, 4}</code> | <code class="language-plaintext highlighter-rouge">FALSE</code>   | 此集的8不在域中    |
| <code class="language-plaintext highlighter-rouge">{1, 2, 3}</code>    | <code class="language-plaintext highlighter-rouge">{1, 2, 3, 4}</code> | <code class="language-plaintext highlighter-rouge">TRUE</code>    | 此集的所有元素都在域中 |
由此得到 IMMP的宏定义：</p>

<pre><code class="language-tla+">macro IMMP(Moko) begin
    Judgement := \A m \in Moko.mio : m \in Moko.ilio
end macro;
</code></pre>

<p>那么同样可以得到IVMP的宏定义：</p>

<pre><code class="language-tla+">macro IVMP(Moko) begin
    Judgement := \A m \in Moko.vio : m \in Moko.ilio
end macro;
</code></pre>

<p>现在可以得到IFVP的宏定义：</p>

<pre><code class="language-tla+">macro IFVP(Moko) begin
    Judgement := IMMP(Moko) /\ IVMP(Moko)
end macro;
</code></pre>

<p>不对，这样会出现错误，因为IMMP和IVMP都会修改Judgement的值。</p>

<p>为什么不能让宏命令本身返回值呢？</p>

<p>不能，Plucal的宏命令只能是 <code class="language-plaintext highlighter-rouge">:=</code> 的形式。</p>

<p>那么为什么不把IVMP之类的语句放在定义里呢？</p>

<pre><code class="language-tla+">EXTENDS Integers, FiniteSets, TLC

(*--algorithm t2
    variables
        Mok = [mio |-&gt; {1, 2, 3, 8}, vio |-&gt; {1, 2}, ilio |-&gt; {1, 2, 3, 4}],
        Judgement = TRUE;

define
    IMMP(Moko) == \A m \in Moko.mio : m \in Moko.ilio
    IVMP(Moko) == \A m \in Moko.vio : m \in Moko.ilio
end define;

begin
P1: Judgement := IMMP(Mok);

end algorithm;*)   
</code></pre>

<p>不变量设置为Judgement，测试数据如下：</p>

<table>
  <thead>
    <tr>
      <th>Moko.mio</th>
      <th>Moko.ilio</th>
      <th>Judgement</th>
      <th>解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">{1, 2, 3, 8}</code></td>
      <td><code class="language-plaintext highlighter-rouge">{1, 2, 3, 4}</code></td>
      <td><code class="language-plaintext highlighter-rouge">FALSE</code></td>
      <td>此集的8不在域中</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">{1, 2, 3}</code></td>
      <td><code class="language-plaintext highlighter-rouge">{1, 2, 3, 4}</code></td>
      <td><code class="language-plaintext highlighter-rouge">TRUE</code></td>
      <td>此集的所有元素都在域中</td>
    </tr>
  </tbody>
</table>

<p>这样定义要比集合差之类的简单多了。</p>

<h2 id="q4多种开始状态">Q4：多种开始状态</h2>

<p>代码格式：</p>

<pre><code class="language-tla+">variables x in set
</code></pre>

<h2 id="q5with-和-either">Q5：With 和 Either</h2>

<p>Either 语法格式</p>

<pre><code class="language-tla+">either
  \* branch 1
or
  \* branch 2
  \* ...
or
  \* branch n
end either;
</code></pre>

<p>With 语法格式</p>

<pre><code class="language-tla+">with var = value do
  \* body
end with;
\* or
with var \in set do
  \* body
end with;
</code></pre>

<h2 id="参考">参考</h2>
<ul>
  <li>Pratical TLA+</li>
</ul>]]></content><author><name>甲与</name></author><category term="TLAplus" /><summary type="html"><![CDATA[探索一下 tlaplus pluscal 的基本功能。]]></summary></entry></feed>